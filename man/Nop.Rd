% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nop.R
\name{Nop}
\alias{Nop}
\title{Nop Object}
\value{
Either the \code{Nop} object to allow for method chaining, or a result.
Please refer to the respective documentation for the output of the different
methods.
}
\description{
A \code{Nop} object defines a numerical optimization problem.
}
\section{Getting started}{
\subsection{Step 1: Create a \code{Nop} object}{

Call \code{object <- Nop$new(f, npar, ...)} where
\itemize{
\item \code{f} is a single-valued function to be optimized with respect to its
first argument,
\item \code{npar} is the length of the first argument of \code{f},
\item and \code{...} are additional arguments for \code{f} (if any).
The additional arguments can be managed via the \code{$argument()} method.
}
}

\subsection{Step 2: Specify numerical optimizers}{

Call \code{object$set_optimizer(<optimizer object>)}, where
\code{<optimizer object>} is an object of class \code{optimizer}, which can
be created with the \code{\link[optimizeR]{define_optimizer}} function.
Two \code{optimizer} objects are already available:
\itemize{
\item \code{\link[optimizeR]{optimizer_nlm}}
\item \code{\link[optimizeR]{optimizer_optim}}
}
}

\subsection{Step 3: Select initial values}{

Call one of the following methods to define starting values for the
optimization (the different initialization strategies are illustrated in the
package vignettes):
\itemize{
\item \code{object$initialize_fixed()} for fixed initial values,
\item \code{object$initialize_random()} for random initial values,
\item \code{object$initialize_continue()} for initial values based on parameter
estimates from previous optimization runs.
}
}

\subsection{Step 4: Optimization}{

Call \code{object$optimize()} for the optimization. See below for methods
to access and analyze the results.
}
}

\section{Methods for accessing and analyzing the results}{
\itemize{
\item \code{$results()} returns a \code{list} of the optimization results,
\item \code{$summary()} summarizes the results in a \code{data.frame},
\item \code{$optima()} returns a frequency table of the identified optima,
\item \code{$plot()} visualizes the optimization times or values,
\item \code{$best()} returns the best found parameter vector or function value.
}
}

\section{Other methods and fields}{
\itemize{
\item \code{object$validate()} checks the configurations of a \code{Nop} object,
\item \code{object$evaluate()} evaluates the target function at some point,
\item \code{$delete()} deletes optimization results,
\item \code{$elements()} returns the names of the available elements in the
optimizer outputs,
\item \code{$runs()} returns the number of performed optimization runs,
\item \code{$trace()} calculates the trace of an optimization path,
\item \code{$initialize_reset()} resets the initial values,
\item \code{$true()} stores the true best function value and parameter vector
(if available),
\item \code{$f_name} stores the function name,
\item \code{$npar} stores the length of the target argument,
\item \code{$fresh_label} generates a new label for the optimization,
\item \code{$reserved_labels} returns the names of reserved labels.
}
}

\section{Progress bar during optimization}{
Displaying progress during multiple optimization runs via the
\code{{progressr}} package is supported. To get started, run
\preformatted{
progressr::handlers(global = TRUE)
}
and see \code{\link[progressr]{handlers}} for details.
}

\section{Parallel optimization}{
Parallel computation of multiple optimization runs via the \code{{future}}
package is supported. To get started, run one of
\preformatted{
future::plan(future::sequential)
future::plan(future::multisession)
future::plan(future::multicore)
}
and see \code{\link[future]{plan}} for details.
}

\examples{
# Minimization of the Ackley function
ackley <- TestFunctions::TF_ackley

Nop_ackley <- Nop$new(f = ackley, npar = 2)$  # define the Nop object
  set_optimizer(
    optimizeR:Optimizer("stats::nlm")         # select the nlm optimizer
  )$
  initialize_random(
    sampler = function() rnorm(2, mean = 0, sd = 3),
    runs = 100, seed = 1
  )$                                          # initialize 100 times randomly
  optimize(which_direction = "min")           # minimize

Nop_ackley$optima(print.rows = 5, digits = 1) # get optima overview

Nop_ackley$best("parameter")                  # return best parameter vector

}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{npar}}{The length(s) of the target argument(s).}

\item{\code{fresh_label}}{A new optimization label that has not been used yet.}

\item{\code{verbose}}{Either \code{TRUE} to print progress and details, or \code{FALSE} to hide
such messages.
By default, \code{verbose = getOption("verbose", default = FALSE)}.}

\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
By default, \code{digits = getOption("digits", default = 7)}.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Nop-new}{\code{Nop$new()}}
\item \href{#method-Nop-print}{\code{Nop$print()}}
\item \href{#method-Nop-fixed_argument}{\code{Nop$fixed_argument()}}
\item \href{#method-Nop-set_optimizer}{\code{Nop$set_optimizer()}}
\item \href{#method-Nop-evaluate}{\code{Nop$evaluate()}}
\item \href{#method-Nop-initialize_fixed}{\code{Nop$initialize_fixed()}}
\item \href{#method-Nop-initialize_random}{\code{Nop$initialize_random()}}
\item \href{#method-Nop-initialize_grid}{\code{Nop$initialize_grid()}}
\item \href{#method-Nop-initialize_continue}{\code{Nop$initialize_continue()}}
\item \href{#method-Nop-initialize_custom}{\code{Nop$initialize_custom()}}
\item \href{#method-Nop-initialize_promising}{\code{Nop$initialize_promising()}}
\item \href{#method-Nop-initialize_transform}{\code{Nop$initialize_transform()}}
\item \href{#method-Nop-initialize_reset}{\code{Nop$initialize_reset()}}
\item \href{#method-Nop-optimize}{\code{Nop$optimize()}}
\item \href{#method-Nop-validate}{\code{Nop$validate()}}
\item \href{#method-Nop-elements}{\code{Nop$elements()}}
\item \href{#method-Nop-runs}{\code{Nop$runs()}}
\item \href{#method-Nop-results}{\code{Nop$results()}}
\item \href{#method-Nop-summary}{\code{Nop$summary()}}
\item \href{#method-Nop-delete}{\code{Nop$delete()}}
\item \href{#method-Nop-optima}{\code{Nop$optima()}}
\item \href{#method-Nop-plot}{\code{Nop$plot()}}
\item \href{#method-Nop-trace}{\code{Nop$trace()}}
\item \href{#method-Nop-true}{\code{Nop$true()}}
\item \href{#method-Nop-best}{\code{Nop$best()}}
\item \href{#method-Nop-closest}{\code{Nop$closest()}}
\item \href{#method-Nop-clone}{\code{Nop$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-new"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-new}{}}}
\subsection{Method \code{new()}}{
Creates a new \code{Nop} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$new(objective, target, npar, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{objective}}{The \code{function} to be optimized (the so-called objective function).
It should return a single \code{numeric} value.}

\item{\code{target}}{The names of the arguments over which \code{f} will be optimized (the
so-called target arguments).
Each of these arguments should expect a \code{numeric} \code{vector}.}

\item{\code{npar}}{The lengths of the target arguments.}

\item{\code{...}}{Optionally additional, named arguments for \code{f} which are kept fixed
during the optimization.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-print"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-print}{}}}
\subsection{Method \code{print()}}{
Prints details of the numerical optimization problem.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$print(digits = getOption("digits", default = 7), ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
This can be defined globally via \code{self$digits}.
By default, \code{digits = getOption("digits", default = 7)}.}

\item{\code{...}}{Currently not used.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-fixed_argument"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-fixed_argument}{}}}
\subsection{Method \code{fixed_argument()}}{
Manages additional (i.e., in addition to the target argument) arguments
for \code{f}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$fixed_argument(action, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{action}}{One of:
\itemize{
\item \code{"set"} to set an argument,
\item \code{"get"} to extract an argument value,
\item \code{"remove"} to remove an argument,
\item \code{"reset"} to reset an argument to the original value,
\item \code{"modify"} to modify an argument to a new value (the original
value is saved and can be recovered via \code{"reset"}),
\item \code{"subset"} to subset an argument,
\item \code{"standardize"} to standardize a \code{numeric} argument.
}}

\item{\code{...}}{Additional parameters depending on the \code{action}:
\itemize{
\item if \code{action = "set"} or \code{"modify"}, one or more named
arguments,
\item if \code{action = "get"}, \code{"remove"}, or \code{"reset"},
the argument \code{name},
\item if \code{action = "subset"},
\itemize{
\item the argument \code{name},
\item \code{byrow}, either \code{TRUE} to subset
row-wise (default) or \code{FALSE} to subset column-wise,
\item \code{how}, specifying how to subset, either \code{"random"}
(default), \code{"first"}, \code{"last"}, \code{"similar"}, or
\code{"dissimilar"}.
\item \code{proportion}, a \code{numeric} between \code{0} and \code{1},
specifying the subset proportion (the default is \code{0.5}),
\item \code{centers}, passed on to \code{\link[stats]{kmeans}}
if \code{how = "(dis)similar"} (by default, \code{centers = 2}),
\item \code{ignore}, an \code{integer} vector of row indices (or column
indices if \code{byrow = FALSE}) to ignore for clustering if
\code{how = "(dis)similar"},
\item \code{seed}, an \code{integer} for reproducibility,
}
\item if \code{action = "standardize"},
\itemize{
\item the argument \code{name},
\item \code{byrow}, either \code{TRUE} to standardize
row-wise or \code{FALSE} to standardize column-wise (default),
\item \code{center}, set to \code{TRUE} (default) for centering, resulting
in zero mean,
\item \code{scale}, set to \code{TRUE} (default) for scaling, resulting in
unit variance,
\item \code{ignore}, an \code{integer} vector of column indices (or row
indices if \code{byrow = TRUE}) to not standardize,
\item \code{jointly}, a \code{list} of \code{integer} vectors with column
indices (or row indices if \code{byrow = TRUE}) to standardize
jointly.
}
}}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Using \code{how = "similar"} or \code{how = "dissimilar"} for subsetting
applies k-means clustering via \code{\link[stats]{kmeans}} and requires
that the selected argument is \code{numeric}
}

\subsection{Returns}{
The argument value if \code{action = "get"} and invisibly the \code{Nop}
object, else. If \code{action = "standardize"}, the \code{numeric}
centering and scaling used (if any) are added as
attributes \code{"standardized:center"} and \code{"standardized:scale"}
to the argument.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-set_optimizer"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-set_optimizer}{}}}
\subsection{Method \code{set_optimizer()}}{
Specifies a numerical optimizer.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$set_optimizer(optimizer, optimizer_label = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{optimizer}}{An object of class \code{optimizer}, which can be created via
\code{\link[optimizeR]{Optimizer}}.}

\item{\code{optimizer_label}}{A \code{character}, a \emph{unique} label for the optimizer.
By default \code{label = NULL}, in which case the default label saved
inside \code{optimizer} is used.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-evaluate"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-evaluate}{}}}
\subsection{Method \code{evaluate()}}{
Evaluates the objective function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$evaluate(
  at = stats::rnorm(sum(self$npar)),
  seconds = Inf,
  hide_warnings = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{at}}{A \code{numeric} vector of length \code{sum(npar)}, the point where the
function is evaluated.
By default, \code{at = rnorm(sum(self$npar))}, i.e., random values drawn
from a standard normal distribution.}

\item{\code{seconds}}{A \code{numeric}, a time limit in seconds. Optimization is interrupted
prematurely if \code{seconds} is exceeded.
This currently only works reliably under Windows OS.
No time limit if \code{seconds = Inf} (the default).}

\item{\code{hide_warnings}}{Either \code{TRUE} or \code{FALSE} to hide (show) warning messages
during the function evaluation or optimization.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Either:
\itemize{
\item a \code{numeric} value, the function value at \code{at},
\item \code{"time limit reached"} if the time limit was reached,
\item the error message if the evaluation failed.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_fixed"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_fixed}{}}}
\subsection{Method \code{initialize_fixed()}}{
Defines fixed initial values for the optimization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_fixed(at)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{at}}{A \code{numeric} \code{vector} of length \code{self$sum(npar)}, the
initial parameter vector. It can also be a \code{list} of such vectors.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_random"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_random}{}}}
\subsection{Method \code{initialize_random()}}{
Defines random initial values for the optimization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_random(
  sampler = function() stats::rnorm(sum(self$npar)),
  runs = 1,
  seed = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{sampler}}{A \code{function} without any arguments that returns a \code{numeric}
vector of length \code{sum(self$npar)}.
By default, \code{sampler = rnorm(sum(self$npar))}, i.e., random values
drawn from a standard normal distribution.}

\item{\code{runs}}{An \code{integer}, the number of optimization runs.
By default, \code{runs = 1}.}

\item{\code{seed}}{Passed on to \code{\link{set.seed}} for reproducibility.
Can be \code{NULL} (default) for no seed or to reset the current seed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_grid"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_grid}{}}}
\subsection{Method \code{initialize_grid()}}{
Defines grid initial values for the optimization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_grid(
  lower = rep(0, length(sum(self$npar))),
  upper = rep(1, length(sum(self$npar))),
  breaks = rep(3, length(sum(self$npar))),
  jitter = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lower}}{A \code{numeric} \code{vector} of length \code{self$sum(npar)}, the
lower grid bounds for each parameter dimension.}

\item{\code{upper}}{A \code{numeric} \code{vector} of length \code{self$sum(npar)}, the
upper grid bounds for each parameter dimension.}

\item{\code{breaks}}{A \code{numeric} \code{vector} of length \code{self$sum(npar)}, the
number of breaks for each parameter dimension.}

\item{\code{jitter}}{Either \code{TRUE} to add noise to the grid points for a random grid
layout, or \code{FALSE} (default), else.}

\item{\code{...}}{Optional parameters passed to \code{\link[base]{jitter}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_continue"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_continue}{}}}
\subsection{Method \code{initialize_continue()}}{
Defines initial values based on results from previous optimizations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_continue(
  which_run = "last",
  which_optimizer = "all",
  which_direction = c("min", "max")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_custom"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_custom}{}}}
\subsection{Method \code{initialize_custom()}}{
Defines custom initial values for the optimization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_custom(at, seconds = rep(0, length(at)), type = "custom")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{at}}{A \code{list} of \code{numeric} \code{vector}s, each of length
\code{self$sum(npar)}, the initial parameter vector.}

\item{\code{seconds}}{A \code{numeric} \code{vector} of the same length as \code{at}. It
contains the number of seconds it took to obtain these initial values,
which is added to the overall optimization time.}

\item{\code{type}}{A single \code{character}, the type of the initial values.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_promising"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_promising}{}}}
\subsection{Method \code{initialize_promising()}}{
Defines a subset of promising initial values for the optimization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_promising(proportion, condition = "gradient_steep")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{proportion}}{A \code{numeric} between 0 and 1, the subset proportion.}

\item{\code{condition}}{Defines the condition on which the initial values are selected, either
\itemize{
\item \code{"gradient_steep"} for the points where the numerical gradient is steepest,
\item \code{"value_low"} for the points where the function value is lowest,
\item \code{"value_high"} for the points where the function value is highest.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_transform"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_transform}{}}}
\subsection{Method \code{initialize_transform()}}{
Transforms the currently defined initial values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_transform(transform = function(x) x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{transform}}{A \code{function} for transforming the initial values. It must be able to
receive and return a \code{numeric} \code{vector} of length
\code{sum(self$npar)}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-initialize_reset"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-initialize_reset}{}}}
\subsection{Method \code{initialize_reset()}}{
Resets the currently defined initial values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$initialize_reset()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-optimize"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-optimize}{}}}
\subsection{Method \code{optimize()}}{
Optimizes the function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$optimize(
  optimization_label = self$fresh_label,
  which_optimizer = "all",
  which_direction = "min",
  seconds = Inf,
  hide_warnings = TRUE,
  reset_initial = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{optimization_label}}{A \code{character} to specify a label for the optimization.
Labels are useful to distinguish optimization runs.
By default, \code{self$fresh_label} creates a new label.}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{seconds}}{A \code{numeric}, a time limit in seconds. Optimization is interrupted
prematurely if \code{seconds} is exceeded.
This currently only works reliably under Windows OS.
No time limit if \code{seconds = Inf} (the default).}

\item{\code{hide_warnings}}{Either \code{TRUE} or \code{FALSE} to hide (show) warning messages
during the function evaluation or optimization.}

\item{\code{reset_initial}}{Either \code{TRUE} (default) to reset the initial values after the
optimization, or \code{FALSE}, else.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Parallel computation of multiple optimization runs via the \code{{future}}
package and displaying progress via the \code{{progressr}} package are supported.
}

\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-validate"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-validate}{}}}
\subsection{Method \code{validate()}}{
Validates the configuration of a \code{Nop} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$validate(
  at = stats::rnorm(self$npar),
  which_optimizer = "all",
  which_direction = "min",
  seconds = 10
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{at}}{A \code{numeric} vector of length \code{npar}, the point where the
function and the optimizers are tested.
By default, \code{at = rnorm(self$npar)}, i.e., random values drawn
from a standard normal distribution.}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{seconds}}{A \code{numeric}, a time limit in seconds. Optimization is interrupted
prematurely if \code{seconds} is exceeded.
This currently only works reliably under Windows OS.
No time limit if \code{seconds = Inf} (the default).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly \code{TRUE} if the tests are successful.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-elements"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-elements}{}}}
\subsection{Method \code{elements()}}{
Returns the names of available elements in the optimization results.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$elements(which_optimizer = "all", group_by = NULL, verbose = self$verbose)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{group_by}}{Selects how the output is grouped. Either:
\itemize{
\item \code{NULL} to not group (default),
\item \code{".optimization_label"} to group by optimization label,
\item \code{".optimizer_label"} to group by optimizer label.
}}

\item{\code{verbose}}{Either \code{TRUE} to print progress and details, or \code{FALSE} to hide
such messages.
This can be defined globally via \code{self$verbose}.
By default, \code{verbose = getOption("verbose", default = FALSE)}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{character} if \code{group_by = NULL}, otherwise a
\code{list} of \code{character}s.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-runs"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-runs}{}}}
\subsection{Method \code{runs()}}{
Returns the number of optimization results.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$runs(
  which_run = "all",
  which_direction = c("min", "max"),
  which_optimizer = "all",
  which_element = "all"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_element}}{Selects elements of optimization results. Either:
\itemize{
\item \code{"all"} for all available elements,
\item a \code{character} (vector) with names of specific elements (see
\code{$elements()} for the names of available elements per optimizer),
where the following elements are always available:
\itemize{
\item \code{"value"}, the function value at the optimum,
\item \code{"parameter"}, the parameter at which the optimum value is obtained,
\item \code{"seconds"}, the optimization time in seconds,
\item \code{"initial"}, the initial parameters,
\item \code{"error"}, indicating whether an error occurred,
\item \code{"error_message"}, the error message (if any).
}
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{integer}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-results"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-results}{}}}
\subsection{Method \code{results()}}{
Returns optimization results.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$results(
  which_run = "all",
  which_direction = c("min", "max"),
  which_optimizer = "all",
  which_element = "all",
  add_identifier = character(),
  group_by = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_element}}{Selects elements of optimization results. Either:
\itemize{
\item \code{"all"} for all available elements,
\item a \code{character} (vector) with names of specific elements (see
\code{$elements()} for the names of available elements per optimizer),
where the following elements are always available:
\itemize{
\item \code{"value"}, the function value at the optimum,
\item \code{"parameter"}, the parameter at which the optimum value is obtained,
\item \code{"seconds"}, the optimization time in seconds,
\item \code{"initial"}, the initial parameters,
\item \code{"error"}, indicating whether an error occurred,
\item \code{"error_message"}, the error message (if any).
}
}}

\item{\code{add_identifier}}{Selects identifiers to be added to the output. Can be one or more of:
\itemize{
\item \code{".run_id"}, which yields an \code{integer} that identifies the
optimization run,
\item \code{".optimization_label"}, which yields a \code{character} that
identifies custom groups of optimization runs,
\item \code{".optimizer_label"}, which yields a \code{character} that identifies
the optimizer,
\item \code{".comparable"}, which yields a \code{logical} that identifies whether
the result is comparable,
\item \code{".direction"}, which yields \code{"min"} or \code{"max"} that
identifies whether the result corresponds to minimization or maximization.
}}

\item{\code{group_by}}{Selects how the output is grouped. Either:
\itemize{
\item \code{NULL} to not group (default),
\item \code{".optimization_label"} to group by optimization label,
\item \code{".optimizer_label"} to group by optimizer label.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{list} if \code{group_by = NULL}, otherwise a \code{list} of
\code{list}s.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-summary"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-summary}{}}}
\subsection{Method \code{summary()}}{
Provides an overview of the optimization runs.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$summary(
  which_element = c("value", "parameter"),
  which_run = "all",
  which_optimizer = "all",
  which_direction = c("min", "max"),
  add_identifier = character(),
  group_by = NULL,
  digits = self$digits
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_element}}{Selects elements of optimization results. Either:
\itemize{
\item \code{"all"} for all available elements,
\item a \code{character} (vector) with names of specific elements (see
\code{$elements()} for the names of available elements per optimizer),
where the following elements are always available:
\itemize{
\item \code{"value"}, the function value at the optimum,
\item \code{"parameter"}, the parameter at which the optimum value is obtained,
\item \code{"seconds"}, the optimization time in seconds,
\item \code{"initial"}, the initial parameters,
\item \code{"error"}, indicating whether an error occurred,
\item \code{"error_message"}, the error message (if any).
}
}}

\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{add_identifier}}{Selects identifiers to be added to the output. Can be one or more of:
\itemize{
\item \code{".run_id"}, which yields an \code{integer} that identifies the
optimization run,
\item \code{".optimization_label"}, which yields a \code{character} that
identifies custom groups of optimization runs,
\item \code{".optimizer_label"}, which yields a \code{character} that identifies
the optimizer,
\item \code{".comparable"}, which yields a \code{logical} that identifies whether
the result is comparable,
\item \code{".direction"}, which yields \code{"min"} or \code{"max"} that
identifies whether the result corresponds to minimization or maximization.
}}

\item{\code{group_by}}{Selects how the output is grouped. Either:
\itemize{
\item \code{NULL} to not group (default),
\item \code{".optimization_label"} to group by optimization label,
\item \code{".optimizer_label"} to group by optimizer label.
}}

\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
This can be defined globally via \code{self$digits}.
By default, \code{digits = getOption("digits", default = 7)}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-delete"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-delete}{}}}
\subsection{Method \code{delete()}}{
Deletes optimization results.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$delete(
  which_run,
  which_optimizer = "all",
  which_direction = "min",
  prompt = interactive(),
  replace = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{prompt}}{Either \code{TRUE} to force confirmation, or \code{FALSE} else.}

\item{\code{replace}}{Either \code{TRUE} (default) to replace the deleted identifiers, or
\code{FALSE} else.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly the \code{Nop} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-optima"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-optima}{}}}
\subsection{Method \code{optima()}}{
Provides a frequency overview of the identified optimum values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$optima(
  which_run = "comparable",
  which_direction = "min",
  which_optimizer = "all",
  group_by = NULL,
  sort_by = "frequency",
  digits = self$digits,
  print.rows = 0
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{group_by}}{Selects how the output is grouped. Either:
\itemize{
\item \code{NULL} to not group (default),
\item \code{".optimization_label"} to group by optimization label,
\item \code{".optimizer_label"} to group by optimizer label.
}}

\item{\code{sort_by}}{Either:
\itemize{
\item \code{"frequency"} (default) to sort rows by frequency,
\item \code{"value"} to sort by function value.
}}

\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
This can be defined globally via \code{self$digits}.
By default, \code{digits = getOption("digits", default = 7)}.}

\item{\code{print.rows}}{An \code{integer}, specifying the maximal number of rows to be
printed. No printing if \code{print.rows = 0}, which is the default.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame}. If \code{group_by} is not \code{NULL}, a \code{list}
of \code{data.frame}s.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-plot"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-plot}{}}}
\subsection{Method \code{plot()}}{
Visualizes the optimization time or value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$plot(
  which_element = "seconds",
  group_by = NULL,
  relative = FALSE,
  which_run = "comparable",
  which_direction = c("min", "max"),
  which_optimizer = "all",
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_element}}{Either:
\itemize{
\item \code{"seconds"} to plot the optimization times (default)
\item \code{"value"} to plot the optimization values
}}

\item{\code{group_by}}{Selects how the output is grouped. Either:
\itemize{
\item \code{NULL} to not group (default),
\item \code{".optimization_label"} to group by optimization label,
\item \code{".optimizer_label"} to group by optimizer label.
}}

\item{\code{relative}}{Only if \code{which_element = "seconds"}.
In this case, set to \code{TRUE} to plot relative time differences with
respect to the overall median.}

\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{...}}{Currently not used.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{\link[ggplot2]{ggplot}} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-trace"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-trace}{}}}
\subsection{Method \code{trace()}}{
Capture trace of optimization with \code{stats::nlm()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$trace(
  initial = stats::rnorm(self$npar),
  iterations = 100,
  tolerance = 1e-06,
  which_direction = "min",
  which_element = c("value", "parameter", "gradient", "hessian", "seconds"),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{initial}}{A \code{numeric} vector of length \code{npar}, the starting point for
the optimization.
By default, \code{initial = stats::rnorm(self$npar)}, i.e., random
initial values drawn from a standard normal distribution.}

\item{\code{iterations}}{A positive \code{integer}, the maximum number of iterations before
termination.
By default, \code{interations = 100}.}

\item{\code{tolerance}}{A non-negative \code{numeric}, the minimum allowable absolute change in
the function value before termination.
By default, \code{tolerance = 1e-6}.}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{which_element}}{A \code{character} (vector) of elements to provide in the output for
each iteration. Can be one or more of:
\itemize{
\item \code{"value"}, the current function value,
\item \code{"parameter"}, the current value of each parameter,
\item \code{"gradient"}, the current gradient,
\item \code{"hessian"}, the current Hessian,
\item \code{"seconds"}, the computation time in seconds.
}}

\item{\code{...}}{Additional arguments passed on to \code{\link[stats]{nlm}}.
The arguments \code{iterlim} and \code{hessian} cannot be specified.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame} with iterations in rows, the columns depend on the
specification of \code{which_element}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-true"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-true}{}}}
\subsection{Method \code{true()}}{
Stores the true best function value or parameter vector.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$true(
  input = NULL,
  which_element = "parameter",
  which_direction = "min",
  digits = self$digits
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{input}}{Either
\itemize{
\item \code{NULL} to return the stored true best value or parameter,
\item \code{NA} to remove it,
\item a \code{numeric} to define it.
}}

\item{\code{which_element}}{Selects elements of optimization results. Either:
\itemize{
\item \code{"all"} for all available elements,
\item a \code{character} (vector) with names of specific elements (see
\code{$elements()} for the names of available elements per optimizer),
where the following elements are always available:
\itemize{
\item \code{"value"}, the function value at the optimum,
\item \code{"parameter"}, the parameter at which the optimum value is obtained,
\item \code{"seconds"}, the optimization time in seconds,
\item \code{"initial"}, the initial parameters,
\item \code{"error"}, indicating whether an error occurred,
\item \code{"error_message"}, the error message (if any).
}
}}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
This can be defined globally via \code{self$digits}.
By default, \code{digits = getOption("digits", default = 7)}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Either a \code{numeric} if \code{input} is \code{NULL} or invisibly the
\code{Nop} object, else.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-best"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-best}{}}}
\subsection{Method \code{best()}}{
Returns the best found function value or parameter vector.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$best(
  which_element = "value",
  which_run = c("success", "comparable"),
  which_direction = "min",
  which_optimizer = "all",
  digits = self$digits
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{which_element}}{Either \code{"value"} or \code{"parameter"}.}

\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_direction}}{Either \code{"min"} or \code{"max"}.}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
This can be defined globally via \code{self$digits}.
By default, \code{digits = getOption("digits", default = 7)}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
In the case that multiple optimization runs led to the best value, only
the first one of them is returned.
}

\subsection{Returns}{
A \code{numeric} (vector) with two attributes:
\itemize{
\item \code{.run_id}, the run id that led to the best value,
\item \code{.optimizer_label}, the optimizer that led to the best value.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-closest"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-closest}{}}}
\subsection{Method \code{closest()}}{
Returns the parameter vector corresponding to an optimum closest
(in absolute distance) to a reference \code{value}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$closest(
  value,
  which_run = "all",
  which_direction = c("min", "max"),
  which_optimizer = "all",
  add_identifier = c(".run_id", ".optimizer_label"),
  digits = self$digits
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{A single \code{numeric}, a reference for the value.}

\item{\code{which_run}}{Selects results of optimization runs.

By default, \code{which_run = "all"} for all results.

It can also the filter
\itemize{
\item \code{"success"} for the results of successful optimizations,
\item \code{"comparable"} for the results of comparable optimizations (i.e.,
results obtained for the original optimization problem without any
transformations),
\item a \code{character} (vector) of optimization labels.
}

Filters can be combined and negated (by putting a \code{"!"} in front),
for example \code{which_run = c("!success", "comparable")} filters for
comparable runs that failed.

Alternatively, \code{which_run} can be an \code{integer} (vector) of run ids
as provided for example by \code{$best()}.}

\item{\code{which_direction}}{Selects the type of optimization. Either:
\itemize{
\item \code{"min"} for minimization,
\item \code{"max"} for maximization.
}}

\item{\code{which_optimizer}}{Selects numerical optimizers. Either:
\itemize{
\item \code{"all"} for all specified optimizers,
\item a \code{character} (vector) of specified optimizer labels,
\item an \code{integer} (vector) of optimizer ids as defined in the \code{$print()} output.
}}

\item{\code{add_identifier}}{Selects identifiers to be added to the output. Can be one or more of:
\itemize{
\item \code{".run_id"}, which yields an \code{integer} that identifies the
optimization run,
\item \code{".optimization_label"}, which yields a \code{character} that
identifies custom groups of optimization runs,
\item \code{".optimizer_label"}, which yields a \code{character} that identifies
the optimizer,
\item \code{".comparable"}, which yields a \code{logical} that identifies whether
the result is comparable,
\item \code{".direction"}, which yields \code{"min"} or \code{"max"} that
identifies whether the result corresponds to minimization or maximization.
}}

\item{\code{digits}}{An \code{integer}, the number of decimal places of interest.
This can be defined globally via \code{self$digits}.
By default, \code{digits = getOption("digits", default = 7)}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
In the case of ties, only one of the closest parameter vectors is
returned.
}

\subsection{Returns}{
A \code{numeric} parameter \code{vector} with attributes defined by
\code{add_identifier}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Nop-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Nop-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Nop$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
