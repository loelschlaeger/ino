---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(8, 6),
  out.width = "100%"
)
```

```{r setup}
library(ino)
library(ggplot2)
```

This is the introductory vignette of {ino} explaining the purpose and giving a first example. The vignette was built using R `r paste(R.Version()[6:7], collapse = ".")` with the ino `r utils::packageVersion("ino")` package. 

Whenever we optimise a function, several things need to be carefully considered, such as the choice of starting values, the optimisation algorithm, and ... . The purpose of the {ino} package is to provide a comprehensive toolbox for comparing such different settings. Throughout this vignette, as a case study, we will use the popular `faithful` data set that is provided in base R. This data set provides information about the eruption times of the Old Faithful geyser in Yellowstone National Park, Wyoming, USA.

The vignette contains some general information about ino as well as two examples for optimising a function with fixed and random starting values, respectively.


The faithful data set contains two variables: the eruption time and the waiting time to the next eruption (both given in minutes).

```{r}
data("faithful")
head(faithful)
```

Focussing on the eruption time, a histogram indicates two clusters (short and long eruption times, respectively).

```{r}
ggplot(faithful, aes(x = eruptions, y = ..density..)) + 
  geom_histogram() + xlab("Eruption time (min)") + ylab("Waiting time to next eruption (min)")
```

To illustrate the functions provided by {ino}, we fit a mixture of two normal distributions to the eruption times. (There are many published analyses of data relating to the Old Faithful geyser (see, e.g., refs).) We can simply define the log-likelihood of a mixture of two normal distributions as follows:

```{r}
normal_mixture <- function(theta, data){
  mu <- theta[1:2]
  sigma <- exp(theta[3:4])
  pi <- plogis(theta[5])
  logl <- sum(log(pi * dnorm(data, mu[1], sigma[1]) + (1 - pi) * dnorm(data, mu[2], sigma[2])))
  return(-logl)
}
```

Since we are using the function `nlm()` here which uses unconstrained optimisation, we restrict the standard deviations `sigma` to be positive and `pi` to be between 0 and 1.

To optimise the likelihood function with potentially different sets of starting values, we first setup an ino object using the function `setup_ino`. Behind the scenes, `setup_ino` runs several checks of the inputs, such as checking whether a function and a optimiser have been provided and whether the function f can be called. For `verbose = TRUE`, all checks are printed.

```{r}
x <- setup_ino(
  f = normal_mixture,
  npar = 5,
  data = faithful$eruptions,
  opt = set_optimizer_nlm(),
  verbose = FALSE
)
```

We can print `x` to obtain a quick overview of our ino setup, which includes the name of the function, the number of parameters to estimate, the mpvs, and information about the optimiser:

```{r}
print(x)
```


### Compare different starting values for the optimisation

```{r}
starting_values <- list(c(2, 4, log(1), log(1), qlogis(0.5)), 
                                    c(10, 8, log(0.1), log(0.2), qlogis(0.5)))

for(i in 1:length(starting_values)){
  x <- fixed_initialization(x, at = starting_values[[i]])
}
```

