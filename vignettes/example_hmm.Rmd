---
title: "Example: Hidden Markov Model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Example: Hidden Markov Model}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.dim = c(8, 6), 
  out.width = "75%"
)
library("ino")
set.seed(1)
hmm_ino <- ino::hmm_ino
```

This vignette^[The vignette was build using R `r paste(R.Version()[c("major","minor")], collapse = ".")` with the {ino} `r utils::packageVersion("ino")` package.] describes the workflow of the {ino} package for the likelihood optimization of an hidden Markov model (HMM). For more technical details about HMMs see, e.g.,  Zucchini et al. (2016).

## Data

The example data set considered throughout this vignette covers a time series of share returns from the stock 'Deutsche Bank'. The data set is freely accessible via Yahoo Finance. 

```{r message=FALSE,warning=FALSE}
library("fHMM")
file <- tempfile()
fHMM::download_data(symbol = "DBK.DE", from = "2000-01-01", file = file)
```

```{r message=FALSE,warning=FALSE}
library("dplyr")
db_data <- read.csv(file) %>%
  as_tibble() %>%
  summarize(date = as.Date(Date, format = "%Y-%m-%d"),
            obs = c(NA, diff(log(Close), lag=1) * 100)) %>%
  filter(!is.na(obs)) %>%
  print()
```

```{r}
library("ggplot2")
ggplot(db_data, aes(x = date, y = obs)) +
  geom_point() +
  geom_line() +
  ylab("log-returns [%]")
```

As the share returns are continuous and can take both negative and positive values, we consider an HMM with Gaussian state-dependent distributions. The (log-)likelihood of a Gaussian-HMM is implemented in the function `f_ll_hmm()`.

## Model fitting

We consider an 2-state (`N = 2`) Gaussian-HMM with six parameters (`npar = 6`) to be estimated:

- two for the transition probability matrix (tpm)
- two for the means of the state-dependent distribution
- two for the standard deviations of the state-dependent distribution

The argument `neg =  TRUE` indicates that we minimize the negative log-likelihood, and `opt` selects the optimizer `nlm()`.  

```{r, eval = FALSE}
hmm_ino <- setup_ino(
  f = f_ll_hmm,
  npar = 6,
  data = db_data,
  N = 2,
  neg = TRUE,
  opt = set_optimizer_nlm()
)
```

### Random initialization

We first use randomly chosen starting values. As the first two starting values belong to the tpm, we sample from a normal distribution with mean -1.5 and standard deviation of 0.5 --- as we use the multinomial logit link to ensure that the probabilities are between 0 and 1, a mean of -1.5 correspond to probabilities of staying in state 1 and 2 of about 0.81. For the two means, we draw two random numbers from the standard normal distribution, as the time series above indicates that the most of the returns are fairly close to zero. The starting values for the standard deviations are drawn from a uniform distribution between 0.5 and 2 (note that we exponentiate the standard deviations in the likelihood as they are constrained to be positive, and hence we log transform the starting values).

```{r, eval = FALSE}
sampler <- function() c(log(stats::runif(2, 0.1, 0.9)),
                        stats::rnorm(2),
                        log(stats::runif(2, 0.5, 2)))
hmm_ino <- random_initialization(hmm_ino, runs = 50, sampler = sampler)
```


### Fixed initialization

For selecting fixed starting values, we consider values that lie in the ranges considered above:

```{r, eval = FALSE}
starting_values <- list(c(-2, -2, 0, 0, log(2), log(3)), 
                        c(-1.5, -1.5, -2, 2, log(1), log(2)),
                        c(-1, -1, -3, 3, log(2), log(2)))
for(val in starting_values)
  hmm_ino <- fixed_initialization(hmm_ino, at = val)
```

### Subset initialization

To illustrate the subset initialization strategy, we fit our HMM to the first 50\% of the observation. The starting values for these subsets are chosen randomly from the same distributions as considered above. The function `subset_initialization()` then fits the HMM again to the entire sample using the estimates obtained from the subsets as initial values.

```{r, eval = FALSE}
hmm_ino <- subset_initialization(
  hmm_ino, arg = "data", how = "first", prop = 0.5,
  initialization =  random_initialization(runs = 50, sampler = sampler)
)
```

As the time series of share returns consists of `r nrow(db_data)` observations, we can even try to use fewer observations to fit our model. In the next step, we consider only the first 5% of the observations.


```{r, eval = FALSE}
hmm_ino <- subset_initialization(
  hmm_ino, arg = "data", how = "first", prop = 0.05,
  initialization =  random_initialization(runs = 50, sampler = sampler)
)
```

## Evaluating the optimization runs

### Local optima

Selecting the starting values for HMMs is a well-known issue, as poor starting values may likely result in local maxima. Other R packages designed to fit HMMs discuss this topic in more detail (see, e.g., https://cran.r-project.org/package=moveHMM). We thus first evaluate the optimizations by comparing the likelihood values at convergence, which can be displayed using `overview_optima()`:

```{r}
overview_optima(hmm_ino)
```

The frequency table indicates that `r overview_optima(hmm_ino)[1,2]` out of `r sum(overview_optima(hmm_ino)$frequency)` runs converged to the same likelihood value (`r as.numeric(as.character(overview_optima(hmm_ino)[1,1]))`), which appears to be the global optimum (note these are the negative log-likelihood values).  

Using `summary`, we can investigate the computation time and the resulting optimum for all runs:

```{r}
summary(hmm_ino)
```

To obtain the starting values that lead to the global optimum, we first check which of the optimization runs actually reached the global optimum:

```{r}
which(summary(hmm_ino)$.optimum < 12878)
```

We can access the corresponding initial values of, for example, the first of these runs via:

```{r}
get_vars(hmm_ino, runs = which(summary(hmm_ino)$.optimum < 12878)[1])[[1]]$.init
```


### Optimization time

We use the `plot()` function to investigate the computation time. Intuitively, optimization runs with fixed starting values should be faster than with random starting values, since we have carefully chosen the fixed starting values by investigating the data. The boxplots confirm this intuition: 

```{r}
plot(hmm_ino, by = ".strategy", nrow = 1)
```

Using the output provided by `summary()` and some data manipulation functions provided by the package {dplyr}, we can also compute the average time per strategy:

```{r warning=FALSE,message=FALSE}
summary(hmm_ino) %>% 
  group_by(.strategy) %>% 
  summarise(avg_time = mean(.time))
```

This comparison can however be considered somehow 'unfair', as not all optimization runs lead to the global optimum --- optimization runs that lead to local optima may then have less iterations and hence lower computation time. We can first check which runs lead to the apparent global optimum of `r as.numeric(as.character(overview_optima(hmm_ino)[1,1]))`. For that, we will again use functions from {dplyr}.

```{r}
summary(hmm_ino) %>% 
  mutate(global_optimum = ifelse(.optimum < 12878, 1, 0)) %>% 
  group_by(.strategy) %>% 
  summarise(proportion_global_optimum = mean(global_optimum))
```

While for the fixed starting values all runs converge to the global optimum, the random initialization and subset initialization strategies do sometimes get stuck in local maxima.

Let's again compare the average computation time, but only for those runs that lead to the global optimum:

```{r}
summary(hmm_ino) %>% 
  filter(.optimum < 12878) %>% 
  group_by(.strategy) %>% 
  summarise(mean_time = mean(.time))
```

For those runs that converged to the global optimum, we can again compare the computation time via boxplots:

```{r}
summary(hmm_ino) %>% 
  filter(.optimum < 12878) %>% 
  ggplot(aes(x = "", y = .time)) +
    scale_y_continuous() +
    geom_boxplot() +
    facet_wrap(".strategy", labeller = "label_both", nrow = 1) +
    theme(
      axis.title.x = element_blank(),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank()
    ) +
    ylab("optimization time")
```

While computation time is lowest for the fixed initialization strategy, subset initialization appears to be a promising approach. In particular, when considering the first 5% of the data in a first step, the computation time is most likely to be lower compared to the random initialization approach.


