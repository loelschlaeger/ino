---
title: "Workflow for using ino"
author: "Lennart OelschlÃ¤ger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Workflow for using ino}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(8, 6),
  out.width = "100%"
)
```

This vignette describes the workflow for using ino. It introduces [the `ino` object](#the-ino-object), gives an overview over the [three different function types](#three-different-function-types) implemented in the package, and subsequently presents [an example workflow](#an-example-workflow).

## The `ino` object

We aim to maximize intuition and plainness for users of the ino package. That is why we came up with the idea of having a single object that can be passed to any ino function for specifications, knowledge gathering and evaluations. It is an S3 object of class `ino` which is generated by any of the three specification functions `set_f()`, `set_optimizer()`, and `set_data()`.

## Three different function types

The package consists of three types of functions:

1. Functions that *specify* the optimization problem and the optimizer. They create (or update) [the `ino` object](#the-ino-object) in which the specifications get saved.

2. Functions that *execute* different initialization strategies. They require an ino object as input to read the specifications and update the object with initialization results. 

3. Functions that *evaluate* the initializations. They summarize and visualize the gathered knowledge.

```{r, echo = FALSE}
DiagrammeR::mermaid(diagram = '
sequenceDiagram
  participant specify
  Note left of specify: Specify the optimization problem.
  specify->>execute: Pass the specification.
  loop Arbitrary often.
      execute->>execute: Execute initialization strategies.
  end
  execute->>evaluate: Pass the results.
  loop Arbitrary often.
      evaluate->>evaluate: Evaluate the results.
  end
  Note right of evaluate: New ideas?
  evaluate-->>execute: Try new strategies.
  evaluate-->>specify: Try new specifications.
')
```

## An example workflow

### 0. Load ino

```{r, setup}
# install.packages("ino")
library(ino)
library(magrittr) # Used for better code readability.
```

### 1. Specify the optimization problem

Say we want to numerically minimize the [Ackley function](https://en.wikipedia.org/wiki/Ackley_function).

```{r, define function}
ackley <- function(x) -20*exp(-0.2*sqrt(0.5*(x[1]^2+x[2]^2)))-exp(0.5*(cos(2*pi*x[1])+cos(2*pi*x[2])))+exp(1)+20
```

The function is known to have multiple minima and one global minimum in $x = (0,0)$, so to avoid ending up at an inferior minimum it is worth putting a thought on the initialization.

```{r, visualize function, fig.cap = "Contour plot of the Ackley function"}
x <- y <- seq(-5,5,0.1)
z <- outer(x, y, Vectorize(function(x,y) ackley(c(x,y))))
contour(x, y, z)
```
<!-- TODO: Add better visualization. Perheps own visualization function? -->

We introduce the function to ino via:

```{r, introduce f}
analysis <- ackley %>% set_f(npar = 2)
```

This creates the object `analysis` which is an object of class `ino`. Insights about the initialization will be saved here.

> Remark: If your function is a likelihood function, then this is the right time to also introduce your dataset(s) to ino. See the vignette ... on how to do this.

Next, we need to specify a numerical optimizer, for example nlm from the stats package. We can also set parameters of the optimizer, for example the maximum number of iterations `iterlim`.

```{r, set optimizer}
analysis %<>% set_optimizer(optimizer = "nlm")
```

> Remark: You can specify a list of optimizers here to compare them. See the vignette "Specify numerical optimizer" for details.

Now, all is setup to try different initialization strategies.

### 2. Execute initialization strategies

There is a separate function for each initialization strategy to each of which we can supply our object `analysis`. Let's try random initialization first:

```{r, random initialization}
analysis %<>% random_initialization(runs = 100, lower = -10, upper = 10, sampler = "normal")
```

We initialized `runs = 100` times at random samples from a normal distributions restricted on the interval `lower = -10` to `upper = 10`.

Let's also try fixed initialization at different points:

```{r, fixed initialization}
analysis %<>% fixed_initialization(at = list(c(0,0),c(5,5),c(10,10)))
```

> Remark: Each initialization strategy implemented in ino is documented in its own vignette.

### 3. Evaluate the results

The package provides several functions to evaluate the initialization strategies, for example:

```{r, evaluate optima}
analysis %>% optima
```

```{r, evaluate time}
analysis %>% optimization_time
```

> Remark: Each evaluation function again is documented in its own vignette.
