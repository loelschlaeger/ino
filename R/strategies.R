#' Random initialization
#'
#' @description
#' This function is an implementation of the random initialization strategy.
#'
#' @param x
#' An object of class \code{ino}.
#' @param runs
#' An integer, the number of random initializations. The default is \code{1}.
#' @param sampler
#' A function without any arguments which returns a numeric vector of length
#' \code{npar(x)} with (random) initial values.
#' Per default, \code{sampler = function() stats::rnorm(npar(x))}, i.e. random
#' initial values from a standard normal distribution.
#' @param ncores
#' The number of cores for parallel computation over parameters and optimizers.
#' The default is \code{getOption("ino_ncores")}, which is set to \code{1}
#' when the package is loaded.
#' @param verbose
#' A boolean, which indicates whether progress should be printed.
#' Set to \code{TRUE} (\code{FALSE}) to print (hide) progress.
#' The default is \code{getOption("ino_progress")}, which is set to \code{TRUE}
#' when the package is loaded.
#' @param label
#' A character, the label for the initialization strategy.
#'
#' @return
#' The updated \code{ino} object.
#'
#' @export
#'
#' @keywords
#' strategy
#'
#' @seealso
#' [npar()] to extract the number \code{npar} from an \code{ino} object.

random_initialization <- function(
    x, runs = 1L, sampler = function() stats::rnorm(npar(x)),
    ncores = getOption("ino_ncores"), verbose = getOption("ino_progress"),
    label = "random"
) {
  if (missing(x)) {
    return(strategy_call(match.call(expand.dots = TRUE)))
  }
  check_inputs(
    "x" = x, "runs" = runs, "sampler" = sampler, "ncores" = ncores,
    "verbose" = verbose, "label" = label
  )
  msg <- "Random initial values"
  format <- "Run {cli::pb_current}/{cli::pb_total} | {cli::pb_eta_str}"
  ino_status(msg, verbose = verbose)
  cli::cli_progress_bar(name = msg, total = runs, format = format)
  on.exit(cli::cli_process_done())
  for(run in 1:runs) {
    init <- sampler()
    result <- optimize(x = x, init = init, ncores = ncores, verbose = verbose)
    x <- save_result(x = x, result = result, strategy = label, init = init)
    if (verbose) cli::cli_progress_update()
  }
  return(x)
}

#' Fixed initialization
#'
#' @description
#' This function is an implementation of the fixed initialization strategy.
#'
#' @param at
#' A numeric vector of length \code{npar(x)} with the (fixed) initial values.
#' @inheritParams random_initialization
#'
#' @return
#' The updated \code{ino} object.
#'
#' @export
#'
#' @keywords
#' strategy
#'
#' @seealso
#' [npar()] to extract the number \code{npar} from an \code{ino} object.

fixed_initialization <- function(
    x, at, ncores = getOption("ino_ncores"),
    verbose = getOption("ino_progress"), label = "fixed"
) {
  if (missing(x)) {
    return(strategy_call(match.call(expand.dots = TRUE)))
  }
  check_inputs(
    "x" = x, "at" = at, "ncores" = ncores, "verbose" = verbose, "label" = label
  )
  msg <- ino_set_depth("Fixed initial values")
  ino_status(msg, verbose = verbose)
  result <- optimize(x = x, init = at, ncores = ncores, verbose = verbose)
  save_result(x = x, result = result, strategy = label, init = at)
}

#' Standardize initialization
#'
#' @description
#' This function is an implementation of the standardize initialization
#' strategy.
#'
#' @param arg
#' A character, the name of the argument to be standardized.
#' The argument must be of class \code{matrix} or \code{data.frame}.
#' Per default, \code{arg = "data"}.
#' @param by_col
#' A boolean, set to \code{TRUE} (the default) to standardize column-wise, set
#' to \code{FALSE} to standardize by rows.
#' @param center
#' A boolean, set to \code{TRUE} (the default) for mean standardization.
#' @param scale
#' A boolean, set to \code{TRUE} (the default) for variance standardization.
#' @param ind_ign
#' A numeric vector of column indices (or row indices if \code{by_col = FALSE})
#' that are ignored when standardizing.
#' @param initialization
#' An object of class \code{strategy_call} which determines the initialization.
#' The \code{strategy_call} can be generated by one of the strategy functions
#' (any function with the name \code{*_initialization}), when the \code{x}
#' argument is unspecified.
#' Per default, \code{initialization = random_initialization()}, i.e. random
#' initialization.
#' @inheritParams random_initialization
#'
#' @return
#' The updated \code{ino} object.
#'
#' @export
#'
#' @keywords
#' strategy

standardize_initialization <- function(
    x, arg = "data", by_col = TRUE, center = TRUE, scale = TRUE,
    ind_ign = integer(), initialization = random_initialization(),
    ncores = getOption("ino_ncores"), verbose = getOption("ino_progress"),
    label = "standardize"
) {
  if (missing(x)) {
    return(strategy_call(match.call(expand.dots = TRUE)))
  }
  check_inputs(
    "x" = x, "arg" = arg, "by_col" = by_col, "center" = center, "scale" = scale,
    "ind_ign" = ind_ign, "initialization" = initialization, "ncores" = ncores,
    "verbose" = verbose, "label" = label
  )
  ino_status("Standardizing", verbose = verbose)
  x_st <- clear_ino(x, which = "all")
  x_st$prob$add[[arg]] <- lapply(
    x_st$prob$add[[arg]],
    function(arg_val) {
      if (!by_col) {
        arg_val <- t(arg_val)
      }
      for (i in setdiff(1:ncol(arg_val), ind_ign)) {
        arg_val[, i] <- scale(arg_val[, i], center = center, scale = scale)
      }
      if (!by_col) {
        arg_val <- t(arg_val)
      }
      return(arg_val)
    }
  )
  x_st <- do.call(
    what = rlang::call_name(initialization),
    args = c(
      list("x" = x_st),
      rlang::call_args(initialization)
    )
  )
  x_st$runs$table[[".strategy"]] <- paste(
    label, x_st$runs$table$.strategy, sep = " > ")
  merge_ino(x, x_st)
}

#' Subset initialization
#'
#' @description
#' This function is an implementation of the subset initialization strategy.
#'
#' @param arg
#' A character, the name of the argument to be subsetted.
#' The argument must be of class \code{matrix} or \code{data.frame}.
#' Per default, \code{arg = "data"}.
#' @param by_row
#' A boolean, set to \code{TRUE} (the default) to subset by row, set to
#' \code{FALSE} to subset by column.
#' @param how
#' A character, specifying how to select the subset.
#' Can be one of \code{"random"} (default), \code{"first"}, and \code{"kmeans"}.
#' @param prop
#' A numeric between 0 and 1, specifying the proportion of the subset.
#' @param ind_ign
#' A numeric vector of column indices (or row indices if \code{by_row = FALSE})
#' that are ignored when clustering.
#' Only relevant if \code{how = "kmeans"}.
#' @param kmeans_arg
#' A list of additional arguments for \code{\link[stats]{kmeans}}.
#' Per default, \code{kmeans_arg = list(centers = 2)}, which sets the number of
#' clusters to 2.
#' Only relevant if \code{how = "kmeans"}.
#' @inheritParams standardize_initialization
#'
#' @return
#' The updated \code{ino} object.
#'
#' @export
#'
#' @keywords
#' strategy
#'
#' @importFrom stats kmeans

subset_initialization <- function(
    x, arg = "data", by_row = TRUE, how = "random", prop = 0.5,
    ind_ign = integer(), kmeans_arg = list("centers" = 2),
    initialization = random_initialization(),
    ncores = getOption("ino_ncores"), verbose = getOption("ino_progress"),
    label = paste0("subset(",how,",",prop,")")
) {
  if (missing(x)) {
    return(strategy_call(match.call(expand.dots = TRUE)))
  }
  check_inputs(
    "x" = x, "arg" = arg, "by_row" = by_row, "how" = how, "prop" = prop,
    "ind_ign" = ind_ign, "kmeans_arg" = kmeans_arg,
    "initialization" = initialization, "ncores" = ncores, "verbose" = verbose
  )
  ino_status("Subsetting", verbose = verbose)
  x_subset <- clear_ino(x, which = "all")
  x_subset$prob$add[[arg]] <- lapply(
    x_subset$prob$add[[arg]],
    function(arg_val) {
      if (!by_row) arg_val <- t(arg_val)
      arg_val_length <- nrow(arg_val)
      arg_val_subset_length <- ceiling(arg_val_length * prop)
      if (how == "random") {
        subset_ind <- sort(sample.int(arg_val_length, arg_val_subset_length))
      } else if (how == "first") {
        subset_ind <- 1:arg_val_subset_length
      } else if (how == "kmeans") {
        arg_val_ign <- arg_val
        if (!is.null(ind_ign)) {
          arg_val_ign <- arg_val_ign[, -ind_ign, drop = FALSE]
        }
        kmeans_out <- do.call(
          what = stats::kmeans,
          args = c(list("x" = arg_val_ign), kmeans_arg)
        )
        nc <- ceiling(arg_val_subset_length / kmeans_arg[["centers"]])
        subset_ind <- c()
        for (i in 1:kmeans_arg[["centers"]]) {
          subset_ind_i <- which(kmeans_out$cluster == i)
          subset_ind <- c(subset_ind, sample(
            x = subset_ind_i,
            size = min(nc, length(subset_ind_i))
          ))
        }
        subset_ind <- sort(subset_ind)
      }
      arg_val_subset <- arg_val[subset_ind, , drop = FALSE]
      if (!by_row) arg_val_subset <- t(arg_val_subset)
      return(arg_val_subset)
    }
  )
  x_subset <- do.call(
    what = rlang::call_name(initialization),
    args = c(list("x" = x_subset), rlang::call_args(initialization))
  )
  merge_ino(x, x_subset)
}

#' @noRd
#' @keywords
#' internal

strategy_call <- function(call) {
  class(call) <- c("strategy_call", class(call))
  return(call)
}

#' @exportS3Method
#' @noRd
#' @keywords
#' internal

print.strategy_call <- function(x, ...) {
  cat("<strategy_call>")
}

#' Check inputs
#'
#' @description
#' This helper function centralizes several input checks.
#'
#' @param ...
#' Named inputs to be checked.
#'
#' @return
#' No return value, called for side effects.
#'
#' @keywords
#' internal

check_inputs <- function(...) {
  inputs <- list(...)
  within(inputs, {
    n <- names(inputs)
    if ("x" %in% n) {
      if (!inherits(x, "ino")) {
        ino_stop(
          event = "'x' must be of class 'ino'."
        )
      }
    }
    if ("runs" %in% n) {
      if (length(runs) > 1 || !is_number(runs)) {
        ino_stop(
          event = "'runs' must be a positive number."
        )
      }
    }
    if ("sampler" %in% n) {
      if (!is.function(sampler)) {
        ino_stop(
          event = "'sampler' must be a function."
        )
      }
      sampler_try <- try_silent(sampler())
      if (!is.numeric(sampler_try) || length(sampler_try) != npar(x)) {
        ino_stop(
          event = "'sampler' must return a numeric vector of length 'npar(x)'."
        )
      }
    }
    if ("ncores" %in% n) {
      if(length(ncores) != 1 || !is_number(ncores) ) {
        ino_stop(
          event = "'ncores' must be a positive integer."
        )
      }
    }
    if ("verbose" %in% n) {
      if(length(verbose) != 1 || (!isTRUE(verbose) && !isFALSE(verbose))) {
        no_stop(
          event = "'verbose' must be either TRUE or FALSE."
        )
      }
    }
    if ("at" %in% n) {
      if (!is.numeric(at) || length(at) != npar(x)) {
        ino_stop(
          event = "'at' must be a numeric vector of length 'npar(x)'."
        )
      }
    }
    if ("arg" %in% n) {
      if (!is.character(arg) || length(arg) != 1) {
        ino_stop(
          event = "'arg' must be a character."
        )
      }
      if (!arg %in% names(x$prob$add)) {
        ino_stop(
          event = paste0(
            "'", arg, "' is not an argument of '", x$prob$f_name, "'."
          )
        )
      }
      if (!all(
        sapply(x$prob$add[[arg]], inherits, c("matrix", "data.frame")))
      ) {
        ino_stop(
          event = paste0(
            "Argument '", arg, "' is not a matrix or data frame'."
          )
        )
      }
    }
    if ("by_col" %in% n) {
      if (length(by_col) != 1 || (!isFALSE(by_col) && !isTRUE(by_col))) {
        ino_stop(
          event = "'by_col' must be either TRUE or FALSE."
        )
      }
    }
    if ("center" %in% n) {
      if (length(center) != 1 || (!isFALSE(center) && !isTRUE(center))) {
        ino_stop(
          event = "'center' must be either TRUE or FALSE."
        )
      }
    }
    if ("scale" %in% n) {
      if (length(scale) != 1 || (!isFALSE(scale) && !isTRUE(scale))) {
        ino_stop(
          event = "'scale' must be either TRUE or FALSE."
        )
      }
    }
    if ("ind_ign" %in% n) {
      if (!is.numeric(ind_ign)) {
        ino_stop(
          event = "'ind_ign' must be a numeric vector."
        )
      }
    }
    if ("initialization" %in% n) {
      if (!inherits(initialization, "strategy_call")) {
        ino_stop(
          event = "'initialization' must be of class 'strategy_call'."
        )
      }
    }
    if ("how" %in% n) {
      if (!how %in% c("random", "first", "kmeans")) {
        ino_stop(
          event = "'how' must be one of 'random', 'first', or 'kmeans'."
        )
      }
    }
    if ("prop" %in% n) {
      if (!(is.numeric(prop) && all(prop <= 1) && all(prop >= 0))) {
        ino_stop(
          event = "'prop' must be between 0 and 1."
        )
      }
    }
    if ("by_row" %in% n) {
      if (!(is.logical(by_row) || length(by_row) == 1)) {
        ino_stop(
          event = "'by_row' must be either 'TRUE' or 'FALSE'."
        )
      }
    }
  })
}

#' Optimization
#'
#' @description
#' This helper function performs numerical optimization based on an \code{ino}
#' object and initial values.
#'
#' @param init
#' A numeric vector of length \code{npar(x)}.
#' @inheritParams random_initialization
#'
#' @return
#' A list, each element contains
#' * the set number \code{i} corresponding to \code{grid_ino(x)}
#' * and the list output of \code{\link[optimizeR]{optimizeR}}.
#'
#' @keywords
#' internal
#'
#' @importFrom parallel makeCluster stopCluster
#' @importFrom doSNOW registerDoSNOW
#' @importFrom foreach foreach %dopar%
#' @importFrom optimizeR optimizeR
#' @importFrom progress progress_bar

optimize <- function(x, init, ncores, verbose) {
  stopifnot(is.numeric(init), length(init) == npar(x))
  grid <- grid_ino(x)
  cluster <- parallel::makeCluster(ncores)
  on.exit(parallel::stopCluster(cluster))
  doSNOW::registerDoSNOW(cluster)
  pb <- progress::progress_bar$new(
    format = "Grid set :current/:total", total = length(grid), clear = TRUE
  )
  opts <- structure(
    list(function(n) {
      if (verbose) if (pb$.__enclos_env__$private$total > 1) pb$tick()
    }),
    names = "progress")
  i <- 1
  foreach::foreach(
    i = 1:length(grid), .packages = c("optimizeR"), .options.snow = opts,
    .inorder = FALSE
  ) %dopar% {
    opt <- grid[[i]][[".optimizer"]]
    grid[[i]][[".optimizer"]] <- NULL
    result <- try_silent(
      do.call(
        what = optimizeR::optimizeR,
        args = c(
          list(
            "optimizer" = opt,
            "f" = x$prob$f,
            "p" = init
          ),
          grid[[i]]
        )
      )
    )
    list("i" = i, "result" = result)
  }
}

#' Save results
#'
#' @description
#' This helper function saves the results of optimization runs into the
#' submitted \code{ino} object.
#'
#' @details
#' The results are saved at \code{x$runs}, which is a list of two elements:
#' * The \code{table} element is a data frame. It has a row for each
#'   recorded optimization run, columns contain optimization results. It stores
#'   * the name of the initialization strategy \code{.strategy},
#'   * the optimization time \code{.time} (\code{difftime} object),
#'   * the function value at the optimum \code{.optimum},
#'   * the identifier for the optimizer \code{.optimizer},
#'   * and identifier for additional parameters for the target function.
#' * The \code{pars} element is a list. It has an element for each recorded
#'   optimization run. It stores
#'   * the initial parameter vector \code{.init},
#'   * the parameter estimate \code{.estimate},
#'   * and additional outputs of the optimizer.
#'
#' @param x
#' An object of class \code{ino}.
#' @param result
#' The output of \code{\link{optimize}}.
#' @param strategy
#' The name of the initialization strategy.
#'
#' @return
#' The updated object \code{x}.
#'
#' @keywords
#' internal

save_result <- function(x, result, strategy, init) {
  stopifnot(inherits(x, "ino"), is.list(result), is.character(strategy),
            length(strategy) == 1)
  grid <- grid_ino(x)
  grid_overview <- attr(grid, "overview")
  names_grid_overview <- colnames(grid_overview)
  nopt <- nrow(x$runs$table)
  res_seq <- sapply(result, `[[`, "i")
  res <- lapply(result, `[[`, "result")
  res_fail <- sum(sapply(res, inherits, "fail"))
  if (res_fail > 0) {
    ino_warn(
      event = paste(res_fail, "of", length(res), "runs failed.")
    )
  }
  for (s in res_seq) {
    if (!inherits(res[[s]], "fail")) {
      x$runs$table[nopt + s, ".strategy"] <- strategy
      x$runs$table[nopt + s, ".time"] <- res[[s]][["time"]]
      x$runs$table[nopt + s, ".optimum"] <- res[[s]][["v"]]
      x$runs$table[nopt + s, names_grid_overview] <- grid_overview[s,]
      x$runs$pars[[nopt + s]] <- c(
        list(".init" = init, ".estimate" = res[[s]]$z),
        res[[s]][!names(res[[s]]) %in% c("v","z","time")]
      )
    }
  }
  return(x)
}




