[{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://loelschlaeger.de/ino/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"application-to-financial-data","dir":"Articles","previous_headings":"","what":"Application to financial data","title":"Package demo: Hidden Markov Model","text":"example data set considered throughout vignette covers time series log returns German stock index DAX 30 years. DAX closing prices freely accessible via Yahoo Finance can downloaded via download_data() function fHMM package (Oelschläger, Adam, Michels 2024). transform log-returns using dplyr package (Wickham et al. 2023): time series looks follows:  log-returns continuous can take negative positive values, consider HMM Gaussian state-dependent distributions — note applications instead use t-distributions also model kurtosis (Oelschläger Adam 2021).","code":"library(\"fHMM\") library(\"dplyr\") dax <- download_data(symbol = \"^GDAXI\", from = \"1990-01-01\", to = \"2020-01-01\") %>%   as_tibble() %>%   reframe(     date = as.Date(Date, format = \"%Y-%m-%d\"),     logreturn = c(NA, diff(log(Close), lag = 1))   ) %>%   filter(!is.na(logreturn)) %>%   print() #> # A tibble: 7,475 × 2 #>    date       logreturn #>    <date>         <dbl> #>  1 1990-01-03  0.0429   #>  2 1990-01-04 -0.0197   #>  3 1990-01-05 -0.00989  #>  4 1990-01-08  0.0156   #>  5 1990-01-09  0.0130   #>  6 1990-01-10 -0.0121   #>  7 1990-01-11  0.000201 #>  8 1990-01-12  0.00947  #>  9 1990-01-15 -0.0111   #> 10 1990-01-16 -0.0188   #> # ℹ 7,465 more rows library(\"ggplot2\") ggplot(dax, aes(x = date, y = logreturn)) +   geom_point() +   geom_line() +   scale_x_date() +   scale_y_continuous(labels = scales::label_percent())"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"likelihood-optimization","dir":"Articles","previous_headings":"","what":"Likelihood optimization","title":"Package demo: Hidden Markov Model","text":"consider 2-state (states = 2) Gaussian-HMM (sdds = \"normal\") model bearish bullish market periods. results six parameters (npar = 6) estimated (optimized, respectively): two identified parameters transition probability matrix, two means state-dependent distributions, two standard deviations state-dependent distributions. likelihood function ll_hmm() provided fHMM package. argument negative = TRUE indicates minimize negative log-likelihood. example, optimize using optimizer stats::nlm() (see introductory vignette details specify optimizers):","code":"Nop_hmm <- Nop$new(   f = fHMM::ll_hmm,    npar = 6,    observations = dax$logreturn,   sdds = \"normal\",   states = 2,    negative = TRUE ) Nop_hmm$set_optimizer(optimizeR::Optimizer$new(\"stats::nlm\"))"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"parallel-optimization-and-progress-updates","dir":"Articles","previous_headings":"Likelihood optimization","what":"Parallel optimization and progress updates","title":"Package demo: Hidden Markov Model","text":"convenience, ino package supports parallel computation optimization runs based future package (Bengtsson 2021) printing progress messages based progressr package (Bengtsson 2024). example, calling uses parallel computation 10 parallel R sessions, calling prints progress bar.","code":"future::plan(future::multisession, workers = 10) progressr::handlers(global = TRUE)"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"random-initialization","dir":"Articles","previous_headings":"Likelihood optimization","what":"Random initialization","title":"Package demo: Hidden Markov Model","text":"Choosing random starting values first naive initialization approach, can tested follows: method initialize_random() selects runs = 100 random initial values, drawn standard normal distribution default. Next, optimize() method initiates optimization likelihood function starting values. results labeled \"random_naive\" facilitate comparison later. Instead drawing initial values standard normal distribution, users can define custom sampler function, example: sampler based following ideas: first two starting values belong -diagonal transition probability matrix, draw starting values 𝒰(−2,−1)\\mathcal{U}(-2,-1) distribution — likelihood function uses multinomial logit link ensure probabilities 00 11, value −1.5-1.5 correspond probabilities staying state 1 2 80%80\\%. two means, draw two random numbers standard normal distribution, time series indicates log-returns vary around zero. starting values standard deviations drawn 𝒰(0.5,2)\\mathcal{U}(0.5,2) distribution (note likelihood function exponentiates standard deviations constrained positive, hence log-transform starting values). optimize() method performs runs = 100 optimizations starting values drawn specified distributions:","code":"Nop_hmm$   initialize_random(runs = 100)$   optimize(optimization_label = \"random_naive\") sampler <- function() {   c(stats::runif(2, -2, -1), stats::rnorm(2), log(stats::runif(2, 0.5, 2))) } Nop_hmm$   initialize_random(sampler = sampler, runs = 100)$   optimize(optimization_label = \"random\")"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"grid-initialization-with-educated-guesses","dir":"Articles","previous_headings":"Likelihood optimization","what":"Grid initialization with educated guesses","title":"Package demo: Hidden Markov Model","text":"Another initialization strategy closely relates specifying custom sampler initial values make “educated guesses” consider grid values initialization. can implemented via initialize_grid() method, lower upper limits breaks can specified. , consider grid 64 starting values fall ranges considered :","code":"Nop_hmm$   initialize_grid(     lower = c(-2, -2, -0.1, -0.1, log(0.1), log(0.1)),     upper = c(-1, -1, 0.1, 0.1, log(1), log(1)),     breaks = 2   )$   optimize(optimization_label = \"educated_guess\")"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"subset-initialization","dir":"Articles","previous_headings":"Likelihood optimization","what":"Subset initialization","title":"Package demo: Hidden Markov Model","text":"Since data set large, containing total 7475 log-return observations, might beneficial obtain initial values first fitting model data subset. data subset chosen small enough, estimation subset much faster. hand, data subset chosen large enough still contain enough information, estimates subset already lie close estimates full model provide good initial values full optimization. illustrate subset initialization strategy, consider first quarter observations, can extracted using reduce() method arguments = \"first\" proportion = 0.25. starting values optimizations subset drawn sampler() function defined . use optimize() fit HMM, now data subset. initialize_continue(), use estimates obtained optimization subset initial values fit model entire data set. Finally, entire data set recovered via fixed_argument(\"reset\", argument_name = \"observations\"). skip step, future optimization runs made subset.","code":"Nop_hmm$   reduce_argument(\"observations\", how = \"first\", proportion = 0.25)$   initialize_random(sampler = sampler, runs = 100)$   optimize(optimization_label = \"reduced\")$   fixed_argument(\"reset\", argument_name = \"observations\")$   initialize_continue(\"reduced\")$   optimize(optimization_label = \"initialized_reduced\")"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"standardize-initialization","dir":"Articles","previous_headings":"","what":"Standardize initialization","title":"Package demo: Hidden Markov Model","text":"considered log-returns range -0.1 0.1. Optimization might facilitated standardizing data first. idea can tested via standardize() method: values used standardization can extracted follows: Optimization proceeds usual: Note results obtained standardized optimization problem back-transformed via:","code":"Nop_hmm$standardize_argument(\"observations\") observations <- Nop_hmm$fixed_argument(\"get\", \"observations\") (center <- attr(observations, \"center\")) #> [1] 0.0002183963 (scale <- attr(observations, \"scale\")) #> [1] 0.01387009 Nop_hmm$   initialize_random(sampler = sampler, runs = 100)$   optimize(optimization_label = \"standardized\")$   fixed_argument(action = \"reset\", argument_name = \"observations\") transform <- function(x) {   c(x[1:2], x[3:4] * scale + center, log(exp(x[3:4]) * scale + center)) }"},{"path":[]},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"global-versus-local-optima","dir":"Articles","previous_headings":"Evaluating the optimization runs","what":"Global versus local optima","title":"Package demo: Hidden Markov Model","text":"Selecting starting values HMM likelihood optimization well-known issue, poor starting values may likely result local optima. thus first evaluate optimizations comparing likelihood values convergence, can displayed using optima() method. , sort_by = \"value\" sorts table function value, digitis = 0 ignores decimal places. frequency table indicates 168 364 runs converged smallest (negative) log-likelihood value, appears global optimum (note negative log-likelihood values). However, 196 runs apparently got stuck local optima. Using $results, now can investigate optimum values (\"value\"), corresponding parameter vectors (\"parameter\"), optimization times (\"seconds\") runs (, first shown): final parameter estimates (.e., parameters associated global optimum) can accessed: Next, can compute proportion runs lead apparent global optimum follows (note standardized initialization approach compared approaches ):","code":"Nop_hmm$optima(sort_by_value = TRUE, digits = 0) #> # A tibble: 12 × 2 #>     value     n #>  *  <dbl> <int> #>  1 -22446   168 #>  2 -22445    37 #>  3 -21804     2 #>  4 -21803     1 #>  5 -21423    22 #>  6 -21421     1 #>  7 -21372   128 #>  8 -21371     1 #>  9 -21351     1 #> 10 -21349     1 #> 11 -21295     1 #> 12  41293     1 Nop_hmm$results |> select(value, parameter, seconds) #> # A tibble: 564 × 3 #>      value parameter seconds #>      <dbl> <list>      <dbl> #>  1 -22446. <dbl [6]>   0.682 #>  2 -22446. <dbl [6]>   0.570 #>  3 -22446. <dbl [6]>   0.439 #>  4 -22446. <dbl [6]>   0.583 #>  5 -22446. <dbl [6]>   0.470 #>  6 -21372. <dbl [6]>   0.298 #>  7 -22446. <dbl [6]>   0.411 #>  8 -22446. <dbl [6]>   0.462 #>  9 -21372. <dbl [6]>   0.327 #> 10 -21372. <dbl [6]>   0.344 #> # ℹ 554 more rows Nop_hmm$minimum #> $value #> [1] -22445.58 #>  #> $parameter #> [1] -3.7009455944 -4.5228904822  0.0008467132 -0.0012013768 -4.7213010302 #> [6] -3.8587575292 Nop_hmm$results |>    filter(.original) |>   mutate(global_optimum = value < -22445) |>   group_by(.optimization_label) |>   summarise(proportion = mean(global_optimum, na.rm = TRUE)) #> # A tibble: 4 × 2 #>   .optimization_label proportion #>   <chr>                    <dbl> #> 1 educated_guess           0.891 #> 2 initialized_reduced      0.37  #> 3 random                   0.47  #> 4 random_naive             0.64"},{"path":"https://loelschlaeger.de/ino/articles/example_hmm.html","id":"optimization-time","dir":"Articles","previous_headings":"Evaluating the optimization runs","what":"Optimization time","title":"Package demo: Hidden Markov Model","text":"autoplot() method can used investigate optimization times across initialization strategies (group_by = \".optimization_label\").2  can also compute summary statistics interest, like median computation time standard deviation per strategy: subset standardize approach can improve median optimization time factor 2 example compared random initialization approach. Standardization also reduces standard deviation computation time, indicating stable optimization.","code":"Nop_hmm$results |>    autoplot(group_by = \"optimization\", relative = TRUE) Nop_hmm$results |>   group_by(.optimization_label) %>%   summarise(     median_seconds = median(seconds, na.rm = TRUE),     sd_seconds = sd(seconds, na.rm = TRUE)   ) %>%   arrange(median_seconds) #> # A tibble: 6 × 3 #>   .optimization_label median_seconds sd_seconds #>   <chr>                        <dbl>      <dbl> #> 1 standardized                 0.296      0.115 #> 2 reduced                      0.317      0.165 #> 3 initialized_reduced          0.438      0.266 #> 4 random                       0.579      0.325 #> 5 random_naive                 0.614      0.229 #> 6 educated_guess               0.897      0.367"},{"path":[]},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Introduction to ino","text":"Optimization aims maximize effectiveness, efficiency, functionality various fields. Examples include portfolio selection finance, minimizing air resistance engineering, likelihood maximization statistical modeling. common goal find inputs produce optimal output. scenarios, determining optimality feasible analytical means, example simple objective functions like f:ℝ→ℝ,f(x)=−x2f:\\mathbb{R} \\\\mathbb{R},\\ f(x) = -x^2. first derivative f′(x)=−2xf'(x) = -2x vanishes x=0x = 0, since ff strictly concave, conclude x=0x = 0 unique point f(x)f(x) maximal. However, many optimization problems lack closed-form solutions, requiring numerical optimization. Numerical optimization encompasses algorithms iteratively explore parameter space, seeking improvement function output iteration ultimately converging point improvements possible (Bonnans et al. 2006). R offers various implementations algorithms1. Common algorithms necessity specify initial parameter values. Crucially, initialization can strongly influence optimization time outcomes (Nocedal Wright 2006). Starting non-concave areas risks convergence issues settling local optima instead global optimum, starting flat regions can slow computation, especially critical function evaluations costly. raises two key questions: initialization affect optimization problem? , initial values ensure fast optimization leading global optimum?","code":""},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"package-functionality","dir":"Articles","previous_headings":"","what":"Package functionality","title":"Introduction to ino","text":"introduce ino package (short initialization numerical optimization), designed address aforementioned questions. package facilitates: Investigation impact initial values optimization. Comparison various initialization strategies. Comparison different numerical optimizers. Following object-oriented approach2, package treats numerical optimization problems objects. objects defined real-valued function, target arguments, one optimization algorithms. object provides methods selecting initial values, executing numerical minimization maximization, evaluating optimization results. key advantages using ino package include: Straightforward comparisons among optimizers initialization strategies. Compatibility optimizer implemented R minimization maximization tasks optimizeR framework (Oelschläger Ötting 2025), detailed . Support parallel computation future package (Bengtsson 2021) progress updates via progressr package (Bengtsson 2024).","code":""},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"example-workflow","dir":"Articles","previous_headings":"","what":"Example workflow","title":"Introduction to ino","text":"begin, obtain ino CRAN via:","code":"install.packages(\"ino\") library(\"ino\")"},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"gaussian-mixture-model","dir":"Articles","previous_headings":"Example workflow","what":"Gaussian mixture model","title":"Introduction to ino","text":"example, function optimized likelihood function, computing probability observing given data specified model assumption. parameters maximize likelihood function identified model estimates. method, known maximum likelihood estimation, widely used statistics fitting models empirical data. examine eruption times Old Faithful geyser Yellowstone National Park, Wyoming, USA. data histogram suggests two clusters short long eruption times, respectively:  clusters, assume normal distribution, representing mixture two Gaussian densities model overall eruption times. log-likelihood function3 defined : ℓ(𝛉)=∑=1nlog(λϕμ1,σ12(xi)+(1−λ)ϕμ2,σ22(xi)) \\ell(\\boldsymbol{\\theta}) = \\sum_{=1}^n \\log\\Big( \\lambda \\phi_{\\mu_1, \\sigma_1^2}(x_i) + (1-\\lambda)\\phi_{\\mu_2,\\sigma_2^2} (x_i) \\Big) , sum covers observations 1,…,n=2721, \\dots, n = 272, ϕμ1,σ12\\phi_{\\mu_1, \\sigma_1^2} ϕμ2,σ22\\phi_{\\mu_2, \\sigma_2^2} represent normal density first second cluster, respectively, λ\\lambda mixing proportion. objective find values parameter vector 𝛉=(μ1,μ2,σ1,σ2,λ)\\boldsymbol{\\theta} = (\\mu_1, \\mu_2, \\sigma_1, \\sigma_2, \\lambda) maximize ℓ(𝛉)\\ell(\\boldsymbol{\\theta}). Due complexity problem, analytical solutions feasible, numerical optimization necessary. Remark: Numerical optimization example notably fast due relatively small dataset model two classes. initialization might seem less critical scenario, becomes significant concern problem scales data parameters (Shireman, Steinley, Brusco 2017). Furthermore, even seemingly simple optimization problem susceptible local optima, depending chosen initial values, see . following function computes log-likelihood value ℓ(𝛉)\\ell(\\boldsymbol{\\theta}) given parameters mu, sigma, lambda observation vector data: Remark: ensure positivity standard deviations sigma, apply exponential transformation. Similarly, constrain lambda 00 11, use logit transformation. approach allows us optimize value space ℝ5\\mathbb{R}^5 without need box-constrained optimizers.","code":"library(\"ggplot2\") ggplot(faithful, aes(x = eruptions)) +    geom_histogram(aes(y = after_stat(density)), bins = 30) +    xlab(\"eruption time (min)\") normal_mixture_llk <- function(mu, sigma, lambda, data) {   sigma <- exp(sigma)   lambda <- plogis(lambda)   sum(log(lambda * dnorm(data, mu[1], sigma[1]) + (1 - lambda) * dnorm(data, mu[2], sigma[2]))) } normal_mixture_llk(mu = 1:2, sigma = 3:4, lambda = 5, data = faithful$eruptions) #> [1] -1069.623"},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"initialization-effect","dir":"Articles","previous_headings":"Example workflow","what":"Initialization effect","title":"Introduction to ino","text":"choice initial values influence optimization problem? following, use ino package optimize likelihood function, starting 100 random initial points, compare results. start defining optimization problem:4 call Nop$new() creates Nop object defines numerical optimization problem. saved object name Nop_mixture. future, can interact object invoking methods using syntax Nop_mixture$<method name>(). arguments : f: objective function optimized. target: names target arguments objective optimized. npar: length target arguments. argument data provided, remains constant optimization. Additionally, analytical gradient Hessian function f can provided available. Nop object defined, objective function can evaluated specific value collapsed target arguments: Next, require numerical optimizer. , choose stats::nlm(): optimizer specified, process optimizing function becomes straightforward: Define initial values using one initialize_*() methods (detailed ). Call optimize(). method initialize_random(runs = 20) generates 20 sets random initial values, set independently drawn standard normal distribution default. Subsequently, optimize(which_direction = \"max\") maximizes function, starting generated values. Accessing optimization results achievable $results field: quick overview, optima() method provides frequency table function values obtained optimizer convergence. can choose ignore decimal places using digits = 0. impact initial values outcome apparent. Now, might question implications two maxima, −276-276 −421-421, Gaussian mixture model fit Geyser data. Two parameter vectors stored objects global (presumably global maximum) local (local maximum). interpret parameter estimates terms mean, standard deviation, mixing proportion, .e., form 𝛉=(μ1,μ2,σ1,σ2,λ)\\boldsymbol{\\theta} = (\\mu_1, \\mu_2, \\sigma_1, \\sigma_2, \\lambda), back-transformation restricted parameter space ℝ2×ℝ+2×[0,1]\\mathbb{R}^2 \\times \\mathbb{R}_+^2 \\times [0,1] necessary (mentioned ): estimates global local 𝛉\\boldsymbol{\\theta} correspond following mixture densities:  evident mixture defined global parameter fits much better local, essentially estimates single class.","code":"Nop_mixture <- Nop$new(   f = normal_mixture_llk,               # the objective function   target = c(\"mu\", \"sigma\", \"lambda\"),  # names of target arguments   npar = c(2, 2, 1),                    # lengths of target arguments   data = faithful$eruptions             # values for fixed arguments ) Nop_mixture$evaluate(at = 1:5) # same value as above #> [1] -1069.623 nlm <- optimizeR::Optimizer$new(which = \"stats::nlm\") Nop_mixture$set_optimizer(nlm) set.seed(1) Nop_mixture$   initialize_random(runs = 20)$   optimize(which_direction = \"max\", optimization_label = \"random\") Nop_mixture$results |> head() #> # A tibble: 6 × 13 #>   value parameter seconds initial error gradient   code iterations error_message #>   <dbl> <list>      <dbl> <list>  <lgl> <list>    <int>      <int> <chr>         #> 1 -421. <dbl [5]>  0.100  <dbl>   FALSE <dbl [5]>     1         36 NA            #> 2 -276. <dbl [5]>  0.113  <dbl>   FALSE <dbl [5]>     1         71 NA            #> 3 -421. <dbl [5]>  0.0722 <dbl>   FALSE <dbl [5]>     1         43 NA            #> 4 -276. <dbl [5]>  0.0398 <dbl>   FALSE <dbl [5]>     1         25 NA            #> 5 -421. <dbl [5]>  0.0733 <dbl>   FALSE <dbl [5]>     1         48 NA            #> 6 -421. <dbl [5]>  0.0936 <dbl>   FALSE <dbl [5]>     1         47 NA            #> # ℹ 4 more variables: .optimization_label <chr>, .optimizer_label <chr>, #> #   .direction <chr>, .original <lgl> Nop_mixture$optima(which_direction = \"max\", digits = 0) #> # A tibble: 2 × 2 #>   value     n #> * <dbl> <int> #> 1  -421    12 #> 2  -276     8 global <- Nop_mixture$maximum$parameter library(\"dplyr\") local <- Nop_mixture$results |>   slice_min(abs(value - (-421)), n = 1) |>   pull(parameter) |>                          unlist() transform <- function(theta) c(theta[1:2], exp(theta[3:4]), plogis(theta[5])) (global <- transform(global)) #> [1] 4.2733434 2.0186078 0.4370631 0.2356218 0.6515954 (local <- transform(local)) #> [1] 3.4877815 0.7821391 1.1392698 0.1367844 1.0000000 mixture_density <- function (data, mu, sigma, lambda) {   lambda * dnorm(data, mu[1], sigma[1]) + (1 - lambda) * dnorm(data, mu[2], sigma[2]) } ggplot(faithful, aes(x = eruptions)) +    geom_histogram(aes(y = after_stat(density)), bins = 30) +    labs(x = \"eruption time (min)\", colour = \"parameter\") +   stat_function(     fun = function(x) {       mixture_density(x, mu = global[1:2], sigma = global[3:4], lambda = global[5])     }, aes(color = \"global\"), linewidth = 1   ) +   stat_function(     fun = function(x) {       mixture_density(x, mu = local[1:2], sigma = local[3:4], lambda = local[5])     }, aes(color = \"local\"), linewidth = 1   )"},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"comparing-initialization-strategies","dir":"Articles","previous_headings":"Example workflow","what":"Comparing initialization strategies","title":"Introduction to ino","text":"Different initial values significantly impact results numerical likelihood optimization mixture model, demonstrated far. prompts question optimally choose initial values. ino package offers various initialization methods can easily compared: modify initial values, following methods available: previously applied initialize_random() method. following, compare initialize_grid() combination initialize_promising(). , make “educated guesses” starting values likely close global optimum. Based histogram , means two normal distributions may around 22 44. use sets starting values means around 22 44, respectively. variances, set starting values close 11 (note use log-transformation since restrict standard deviations positive using exponential function likelihood). starting value mixing proportion shall around 0.50.5. use three grid points dimension, shuffle via jitter = TRUE argument. results grid 35=2433^5 = 243 starting values: 243 grid starting values, select 10% proportion locations objective gradient steepest initiate optimization points: ’s evident initial values initialization strategy concerning steepest gradient reliably lead convergence global maximum −276-276 compared random initial values:","code":"Nop_mixture$initialize_grid(   lower = c(1.5, 3.5, log(0.5), log(0.5), qlogis(0.4)), # lower bounds for the grid   upper = c(2.5, 4.5, log(1.5), log(1.5), qlogis(0.6)), # upper bounds for the grid   breaks = c(3, 3, 3, 3, 3),                            # breaks for the grid in each dimension   jitter = TRUE                                         # random shuffle of the grid points ) Nop_mixture$   initialize_promising(proportion = 0.1, condition = \"gradient_large\")$   optimize(which_direction = \"max\", optimization_label = \"promising_grid\") Nop_mixture$optima(which_direction = \"max\", group_by = \"optimization\", digits = 0) #> $promising_grid #> # A tibble: 1 × 2 #>   value     n #>   <dbl> <int> #> 1  -276    25 #>  #> $random #> # A tibble: 2 × 2 #>   value     n #>   <dbl> <int> #> 1  -421    12 #> 2  -276     8 #>  #> attr(,\"class\") #> [1] \"Nop_optima\" \"group_by\"   \"list\""},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"comparing-optimizer-functions","dir":"Articles","previous_headings":"Example workflow","what":"Comparing optimizer functions","title":"Introduction to ino","text":"far, ’ve utilized stats::nlm optimizer, employing Newton-type algorithm. Now, let’s compare results optimization time : stats::optim, alternative R optimizer , default, applies Nelder-Mead algorithm (Nelder Mead 1965), expectation-maximization algorithm em_optimizer, alternative optimization method mixture models, define appendix . incorporate two optimizers Nop_mixture object using optimizeR framework (, em_optimizer already optimizer required framework): Next, initialize 100 random points optimize mixture likelihood three optimizers points: autoplot() method offers visual comparison optimization times:  Among three optimizers, expectation-maximization algorithm evidently fastest case. Moreover, frequently converges value −276-276, stats::optim tends converge various local optima. However, expectation-maximization algorithm also encountered failures couple runs:","code":"optim <- optimizeR::Optimizer$new(which = \"stats::optim\") Nop_mixture$   set_optimizer(optim)$   set_optimizer(em_optimizer) Nop_mixture$   initialize_random(runs = 100)$   optimize(which_direction = \"max\", optimization_label = \"optimizer_comparison\") Nop_mixture$results |>    filter(.optimization_label == \"optimizer_comparison\") |>   autoplot(which_element = \"seconds\", group_by = \"optimizer\", relative = TRUE) +     scale_x_continuous(labels = scales::percent_format()) +     labs(       \"x\" = \"optimization time relative to overall median\",       \"y\" = \"optimizer\"     ) Nop_mixture$optima(which_direction = \"max\", group_by = \"optimizer\", digits = 0)  #> $em #> # A tibble: 3 × 2 #>   value     n #>   <dbl> <int> #> 1  -276    83 #> 2  -421    13 #> 3    NA     4 #>  #> $`stats::nlm` #> # A tibble: 2 × 2 #>   value     n #>   <dbl> <int> #> 1  -421    92 #> 2  -276    53 #>  #> $`stats::optim` #> # A tibble: 24 × 2 #>    value     n #>    <dbl> <int> #>  1  -421    65 #>  2  -276     8 #>  3  -278     3 #>  4  -277     3 #>  5  -293     2 #>  6  -453     1 #>  7  -417     1 #>  8  -416     1 #>  9  -415     1 #> 10  -403     1 #> # ℹ 14 more rows #>  #> attr(,\"class\") #> [1] \"Nop_optima\" \"group_by\"   \"list\""},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"the-solution-to-the-optimization-problem","dir":"Articles","previous_headings":"Example workflow","what":"The solution to the optimization problem","title":"Introduction to ino","text":"Finally, best identified optimum can extracted via:","code":"Nop_mixture$maximum #> $value #> [1] -276.36 #>  #> $parameter #> [1]  2.0186078  4.2733434 -1.4455274 -0.8276776 -0.6260592"},{"path":[]},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"verbose-mode","dir":"Articles","previous_headings":"Appendix","what":"Verbose mode","title":"Introduction to ino","text":"ino package features verbose mode, prints status messages information usage. mode primarily designed new package users provide feedback hints interactions package. Enabling disabling verbose mode can achieved setting verbose field Nop object either TRUE FALSE. example:","code":"Nop_mixture$verbose <- TRUE"},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"the-expectation-maximization-algorithm","dir":"Articles","previous_headings":"Appendix","what":"The expectation-maximization algorithm","title":"Introduction to ino","text":"likelihood function mixture model maximized analytically. However, knew class membership observation, optimization problem collapse independent maximum likelihood estimation two Gaussian distributions, can solved analytically. insight motivates expectation-maximization (EM) algorithm (Dempster, Laird, Rubin 1977), iterates following steps: Initialize 𝛉\\boldsymbol{\\theta} compute ℓ(𝛉)\\ell(\\boldsymbol{\\theta}). Calculate posterior probabilities observation’s class membership, conditional 𝛉\\boldsymbol{\\theta}. Calculate maximum likelihood estimate 𝛉‾\\boldsymbol{\\bar{\\theta}} conditional posterior probabilities step 2. Evaluate ℓ(𝛉‾)\\ell(\\boldsymbol{\\bar{\\theta}}) either stop likelihood improvement ℓ(𝛉‾)−ℓ(𝛉)\\ell(\\boldsymbol{\\bar{\\theta}}) - \\ell(\\boldsymbol{\\theta}) smaller threshold epsilon iteration limit iterlim reached. Otherwise, return step 2. following function implements algorithm:","code":"em <- function(f, theta, ..., epsilon = 1e-08, iterlim = 1000, data) {   llk <- f(theta, ...)   mu <- theta[1:2]   sigma <- exp(theta[3:4])   lambda <- plogis(theta[5])   for (i in 1:iterlim) {     class_1 <- lambda * dnorm(data, mu[1], sigma[1])     class_2 <- (1 - lambda) * dnorm(data, mu[2], sigma[2])     posterior <- class_1 / (class_1 + class_2)     lambda <- mean(posterior)     mu[1] <- mean(posterior * data) / lambda     mu[2] <- (mean(data) - lambda * mu[1]) / (1 - lambda)     sigma[1] <- sqrt(mean(posterior * (data - mu[1])^2) / lambda)     sigma[2] <- sqrt(mean((1 - posterior) * (data - mu[2])^2) / (1 - lambda))     llk_old <- llk     theta <- c(mu, log(sigma), qlogis(lambda))     llk <- f(theta, ...)     if (is.na(llk)) stop(\"em failed\")     if (abs(llk - llk_old) < epsilon) break   }   list(\"llk\" = llk, \"estimate\" = theta, \"iterations\" = i) }"},{"path":"https://loelschlaeger.de/ino/articles/ino.html","id":"defining-optimizers-via-the-optimizer-framework","dir":"Articles","previous_headings":"Appendix","what":"Defining optimizers via the {optimizeR} framework","title":"Introduction to ino","text":"Previously, integrated stats::nlm stats::optim optimizers optimizeR framework using: Employing optimizeR framework crucial ino package maintain consistently named inputs outputs across different optimizers interpretation purposes (generally case). optimizeR package provides dictionary optimizers can directly selected via argument. overview available optimizers, can use: Optimizers implemented packages yet installed shown install required packages, instance, using convenience function optimizeR::install_optimizer_packages(). However, optimizer contained dictionary can incorporated optimizeR framework setting = \"custom\" first: … using definition() method: expectation-maximization algorithm, additional argument data needs defined: details optimizeR package, please refer package homepage.","code":"nlm <- optimizeR::Optimizer$new(which = \"stats::nlm\") optim <- optimizeR::Optimizer$new(which = \"stats::optim\") optimizeR::optimizer_dictionary #> <Dictionary> optimization algorithms  #> Keys:  #> - lbfgsb3c::lbfgsb3c #> - lbfgsb3c::lbfgsb3 #> - lbfgsb3c::lbfgsb3f #> - lbfgsb3c::lbfgsb3x #> - stats::nlm #> - stats::nlminb #> - stats::optim #> - ucminf::ucminf em_optimizer <- optimizeR::Optimizer$new(which = \"custom\") em_optimizer$definition(   algorithm = em,   arg_objective = \"f\",   arg_initial = \"theta\",   out_value = \"llk\",   out_parameter = \"estimate\",   direction = \"max\" ) em_optimizer$set_arguments(   \"data\" = faithful$eruptions )"},{"path":[]},{"path":"https://loelschlaeger.de/ino/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lennart Oelschläger. Author, maintainer. Marius Ötting. Author. Dietmar Bauer. Contributor.","code":""},{"path":"https://loelschlaeger.de/ino/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Oelschläger L, Ötting M (2025). ino: Initialization Numerical Optimization. R package version 1.1.0, https://loelschlaeger.de/ino/.","code":"@Manual{,   title = {ino: Initialization of Numerical Optimization},   author = {Lennart Oelschläger and Marius Ötting},   year = {2025},   note = {R package version 1.1.0},   url = {https://loelschlaeger.de/ino/}, }"},{"path":"https://loelschlaeger.de/ino/index.html","id":"initialization-of-numerical-optimization-","dir":"","previous_headings":"","what":"Initialization of Numerical Optimization","title":"Initialization of Numerical Optimization","text":"ino R package provides framework analyzing role initialization numerical optimization. allows systematic comparisons different initialization strategies optimization algorithms using unified R6 object called Nop. detailed examples usage guidance, please look package vignettes.","code":""},{"path":"https://loelschlaeger.de/ino/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Initialization of Numerical Optimization","text":"can install released version CRAN :","code":"install.packages(\"ino\")"},{"path":"https://loelschlaeger.de/ino/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Initialization of Numerical Optimization","text":"Ackley function multiple local minima one global minimum origin. define numerical optimization problem Nop object, two optimization algorithms stats::nlm() stats::optim(), 40 randomly drawn initial values: can visualize function surface along initial values:  Next, optimize function via previously defined initial values optimizers: example, stats::nlm() appears faster…  … effective locating global minimum: Overall, () 25% initializations successfully converged global minimum.","code":"library(\"ino\") set.seed(1) Nop_ackley <- Nop$new(f = TestFunctions::TF_ackley, npar = 2)$   set_optimizer(optimizeR::Optimizer$new(\"stats::nlm\"))$   set_optimizer(optimizeR::Optimizer$new(\"stats::optim\"))$   initialize_random(runs = 40) library(\"ggplot2\") Nop_ackley |> autoplot() Nop_ackley$optimize() Nop_ackley$results |>    ggplot2::autoplot(\"seconds\", group_by = \"optimizer\", relative = TRUE) +   ggplot2::scale_x_continuous(labels = scales::percent_format()) +   ggplot2::labs(     \"x\" = \"optimization time relative to overall median\",     \"y\" = \"optimizer\"   ) Nop_ackley$optima(digits = 2, group_by = \"optimizer\") #> $`stats::nlm` #> # A tibble: 5 × 2 #>   value     n #>   <dbl> <int> #> 1  0       13 #> 2  2.58    13 #> 3  3.57    10 #> 4  5.38     3 #> 5  4.88     1 #>  #> $`stats::optim` #> # A tibble: 5 × 2 #>   value     n #>   <dbl> <int> #> 1  2.58    17 #> 2  0       12 #> 3  3.57     5 #> 4  4.88     3 #> 5  5.38     3 #>  #> attr(,\"class\") #> [1] \"Nop_optima\" \"group_by\"   \"list\""},{"path":"https://loelschlaeger.de/ino/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Initialization of Numerical Optimization","text":"question, found bug, request feature, want contribute? Please file issue.","code":""},{"path":"https://loelschlaeger.de/ino/index.html","id":"related-r-packages","dir":"","previous_headings":"","what":"Related R packages","title":"Initialization of Numerical Optimization","text":"{trackopt} package tracks parameter value, gradient, Hessian iteration numerical optimizers R. can useful analyzing optimization progress, diagnosing issues, studying convergence behavior. {optimizeR} package provides unified object-oriented framework numerical optimizers R. Allows minimization maximization optimizer, optimization one function argument, measuring computation time, setting time limit long optimization tasks. {ao} package implements iterative process optimizes function alternately performing restricted optimization parameter subsets. Instead joint optimization, breaks optimization problem simpler sub-problems. approach can make optimization feasible joint optimization difficult.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":null,"dir":"Reference","previous_headings":"","what":"Nop Object — Nop","title":"Nop Object — Nop","text":"Nop object defines numerical optimization problem.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"step-create-a-nop-object","dir":"Reference","previous_headings":"","what":"Step 1: Create a Nop object","title":"Nop Object — Nop","text":"Call object <- Nop$new(f, target, npar, ...) f objective function, target names target arguments, npar specifies lengths target arguments, ... additional arguments f. can now evaluate objective function via $evaluate() method.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"step-specify-numerical-optimizers","dir":"Reference","previous_headings":"","what":"Step 2: Specify numerical optimizers","title":"Nop Object — Nop","text":"Call object$set_optimizer(<optimizer object>), <optimizer object> object class optimizer, can created via {optimizeR} package (please refer package homepage details). example, optimizeR::Optimizer$new(= \"stats::nlm\") defines nlm optimizer, optimizeR::Optimizer$new(= \"stats::optim\") defines optim optimizer.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"step-select-initial-values","dir":"Reference","previous_headings":"","what":"Step 3: Select initial values","title":"Nop Object — Nop","text":"Call initialization methods define starting values optimization (different initialization strategies illustrated package vignettes), example: object$initialize_fixed() fixed initial values, object$initialize_random() random initial values, object$initialize_continue() initial values based parameter estimates previous optimization runs.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"step-optimization","dir":"Reference","previous_headings":"","what":"Step 4: Optimization","title":"Nop Object — Nop","text":"Call object$optimize() optimization.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"step-analyze-the-results","dir":"Reference","previous_headings":"","what":"Step 5: Analyze the results","title":"Nop Object — Nop","text":"$results returns tibble optimization results, $optima() lists identified optima, $minimum $maximum return best minimizer maximizer","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"progress-during-optimization","dir":"Reference","previous_headings":"","what":"Progress during optimization","title":"Nop Object — Nop","text":"Displaying progress multiple optimization runs via {progressr} package supported. get started, run see handlers details.","code":"progressr::handlers(global = TRUE)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"parallel-optimization","dir":"Reference","previous_headings":"","what":"Parallel optimization","title":"Nop Object — Nop","text":"Parallel computation multiple optimization runs via {future} package supported. get started, run one see plan details.","code":"future::plan(future::multisession)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Nop Object — Nop","text":"initial_values [list(), read-] currently defined initial values. Use initialize_*() methods add, transform, reset values. results [tibble, read-] Optimization results identifiers: \".optimization_label\" (identifies optimization run) \".optimizer_label\" (identifies optimizer) \".direction\" (identifies optimization direction) \".original\" (identifies results obtained original problem) output associated autoplot method. minimum [list(2), read-] Best value parameter across (original) minimizations. maximum [list(2), read-] Best value parameter across (original) maximizations. npar [integer(), read-] length target argument. verbose [logical(1)] Print progress details? fresh_label [character(1), read-] optimization label used yet.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Nop Object — Nop","text":"Nop$new() Nop$fixed_argument() Nop$reduce_argument() Nop$standardize_argument() Nop$print() Nop$evaluate() Nop$set_optimizer() Nop$initialize_fixed() Nop$initialize_random() Nop$initialize_grid() Nop$initialize_custom() Nop$initialize_continue() Nop$initialize_filter() Nop$initialize_promising() Nop$initialize_transform() Nop$initialize_reset() Nop$optimize() Nop$optima() Nop$deviation() Nop$clone()","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Nop Object — Nop","text":"Creates new Nop object. output associated autoplot method.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$new(f, target = NULL, npar, gradient = NULL, hessian = NULL, ...)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"f [function] function optimized (-called objective function). expected f least one numeric argument, return value f structure numeric(1). target [character()] argument name(s) get optimized (-called target arguments). target arguments must numeric. Can NULL (default), first function argument selected. npar [integer()] length target argument, .e., length(s) argument(s) specified via target. gradient [function | NULL] Optionally function returns gradient f. function call gradient must identical f. Ignored optimizers support user-supplied gradient. hessian [function | NULL] Optionally function returns Hessian f. function call hessian must identical f. Ignored optimizers support user-supplied Hessian. ... Optionally additional function arguments passed f (gradient hessian, specified) fixed optimization.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-fixed-argument-","dir":"Reference","previous_headings":"","what":"Method fixed_argument()","title":"Nop Object — Nop","text":"Manages fixed arguments objective function.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$fixed_argument(action, ...)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"action [character(1)] One : \"set\" set argument, \"get\" extract argument value, \"remove\" remove argument, \"reset\" reset argument original value, \"modify\" modify argument value. Note \"set\" overrides argument value, \"modify\" preserves original value, can recovered via \"reset\". ... Additional parameters depending action: named arguments action = \"set\" \"modify\", single argument name action = \"get\", \"remove\", \"reset\".","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-reduce-argument-","dir":"Reference","previous_headings":"","what":"Method reduce_argument()","title":"Nop Object — Nop","text":"Reduces fixed argument objective function.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$reduce_argument(   argument_name,   proportion = 0.5,   how = \"random\",   centers = 2L,   byrow = TRUE,   ignore = integer() )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"argument_name [character(1)] name fixed argument objective function. proportion, , centers, byrow, ignore Passed portion.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-standardize-argument-","dir":"Reference","previous_headings":"","what":"Method standardize_argument()","title":"Nop Object — Nop","text":"Standardizes fixed argument objective function.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$standardize_argument(   argument_name,   center = TRUE,   scale = TRUE,   byrow = FALSE,   ignore = integer(),   jointly = list() )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"argument_name [character(1)] name fixed argument objective function. center, scale, byrow, ignore, jointly Passed normalize.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Nop Object — Nop","text":"Prints details Nop object.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$print(...)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"... Currently used.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-evaluate-","dir":"Reference","previous_headings":"","what":"Method evaluate()","title":"Nop Object — Nop","text":"Evaluates objective function.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$evaluate(   at = rep(0, sum(self$npar)),   .gradient_as_attribute = FALSE,   .hessian_as_attribute = FALSE )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"[numeric()] values target argument(s), written single vector. Must length sum(self$npar). .gradient_as_attribute, .hessian_as_attribute [logical(1)] Add gradient / Hessian value attributes? gradient / Hessian function specified, numerical approximation used.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-set-optimizer-","dir":"Reference","previous_headings":"","what":"Method set_optimizer()","title":"Nop Object — Nop","text":"Specifies numerical optimizer.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$set_optimizer(optimizer, optimizer_label = optimizer$label)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"optimizer [Optimizer] Optimizer object, can created via Optimizer. optimizer_label [character(1)] (unique) label optimizer.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-fixed-","dir":"Reference","previous_headings":"","what":"Method initialize_fixed()","title":"Nop Object — Nop","text":"Defines fixed initial values optimization.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_fixed(at)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"[integer(self$sum(npar)) | list()] fixed initial parameter vector. can also list vectors.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-random-","dir":"Reference","previous_headings":"","what":"Method initialize_random()","title":"Nop Object — Nop","text":"Defines random initial values optimization.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_random(   runs = 1L,   sampler = function() stats::rnorm(sum(self$npar)) )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"runs [integer(1)] number optimization runs. sampler [function] function without arguments returns numeric vector length sum(self$npar).","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-grid-","dir":"Reference","previous_headings":"","what":"Method initialize_grid()","title":"Nop Object — Nop","text":"Defines grid initial values optimization.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_grid(lower = 0, upper = 1, breaks = 3, jitter = FALSE, ...)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"lower, upper [numeric(1) | numeric(self$sum(npar))] Lower upper grid bounds parameter dimension. breaks [integer(1) | integer(self$sum(npar))] number breaks parameter dimension. jitter Add noise grid points random grid layout? ... Optional parameters passed jitter.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-custom-","dir":"Reference","previous_headings":"","what":"Method initialize_custom()","title":"Nop Object — Nop","text":"Defines custom initial values optimization.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_custom(at, seconds = rep(0, length(at)), type = \"custom\")"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"[list()] list initial parameter vectors. seconds [numeric(length())] number seconds took obtain initial value , added overall optimization time. type [character(1)] type initial values.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-continue-","dir":"Reference","previous_headings":"","what":"Method initialize_continue()","title":"Nop Object — Nop","text":"Defines initial values based results previous optimizations.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_continue(optimization_label)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"optimization_label [character(1)] Label optimization runs select.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-filter-","dir":"Reference","previous_headings":"","what":"Method initialize_filter()","title":"Nop Object — Nop","text":"Filters initial values defined initial values.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_filter(condition)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"condition [character(1)] Defines condition initial values filtered, one : \"gradient_negative points gradient negative, \"gradient_positive points gradient negative, \"hessian_negative\" points Hessian negative definite, \"hessian_positive\" points Hessian positive definite.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-promising-","dir":"Reference","previous_headings":"","what":"Method initialize_promising()","title":"Nop Object — Nop","text":"Selects promising initial values defined initial values.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_promising(proportion, condition)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"proportion [numeric(1)] proportion selected defined initial values. condition [character(1)] Defines condition initial values selected, one : \"value_small\" points function value smallest, \"value_large\" points function value largest, \"gradient_small\" points gradient norm smallest, \"gradient_large\" points gradient norm largest, \"condition_small\" points Hessian condition smallest, \"condition_large\" points Hessian condition largest.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-transform-","dir":"Reference","previous_headings":"","what":"Method initialize_transform()","title":"Nop Object — Nop","text":"Transforms currently defined initial values.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_transform(transformer = function(x) x)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"transformer [function()] function receives returns numeric() length sum(self$npar).","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-initialize-reset-","dir":"Reference","previous_headings":"","what":"Method initialize_reset()","title":"Nop Object — Nop","text":"Resets currently defined initial values.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$initialize_reset()"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-optimize-","dir":"Reference","previous_headings":"","what":"Method optimize()","title":"Nop Object — Nop","text":"Optimizes target function.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$optimize(   optimization_label = self$fresh_label,   which_optimizer = \"all\",   which_direction = \"min\",   lower = NULL,   upper = NULL,   seconds = Inf,   hide_warnings = TRUE,   reset_initial_afterwards = TRUE )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"optimization_label [character(1)] label optimization distinguish optimization runs. Setting label useful using $initialize_continue() method. which_optimizer [character() | integer()] Selects numerical optimizers. Either: \"\" specified optimizers, specific optimizer labels, specified optimizer ids defined print() output. which_direction [character()] Selects direction optimization. One : \"min\" minimization, \"max\" maximization. lower, upper [numeric() | NULL] Optionally lower upper parameter bounds. Ignored optimizers support parameter bounds. seconds [numeric(1)] time limit seconds. Optimization interrupted prematurely seconds exceeded. Note limitations documented setTimeLimit. hide_warnings [logical(1)] Hide warnings optimization? reset_initial_afterwards [logical(1)] Reset initial values optimization?","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nop Object — Nop","text":"Supports: Parallel computation multiple optimization runs via {future} Progress messages via {progressr}","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-optima-","dir":"Reference","previous_headings":"","what":"Method optima()","title":"Nop Object — Nop","text":"Lists identified optima. output associated autoplot method.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$optima(   which_direction = \"min\",   only_original = TRUE,   group_by = NULL,   sort_by_value = FALSE,   digits = getOption(\"digits\", default = 7) )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"which_direction [character()] Selects direction optimization. One : \"min\" minimization, \"max\" maximization. only_original [`logical(1)] Include optima obtained original problem? group_by [`character(1)] Selects output grouped. Either: NULL group, \"optimization\" group optimization label, `\"optimizer\"“ group optimizer label. sort_by_value [`logical(1)] Sort value? Else, sort frequency. digits [`integer(1)] number decimal places.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-deviation-","dir":"Reference","previous_headings":"","what":"Method deviation()","title":"Nop Object — Nop","text":"Compute deviations respect reference parameter. output associated autoplot method.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$deviation(   reference = rep(0, sum(self$npar)),   which_element = \"initial\",   which_direction = \"min\",   which_optimizer = \"all\",   only_original = TRUE,   parameter_labels = paste0(\"x\", seq_len(sum(self$npar))) )"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"reference [numeric()] reference vector length sum(self$npar). which_element [`character(1)] Either \"initial\" deviations respect initial values, \"parameter\" deviations respect estimated parameters. which_direction [character()] Selects direction optimization. One : \"min\" minimization, \"max\" maximization. which_optimizer [character() | integer()] Selects numerical optimizers. Either: \"\" specified optimizers, specific optimizer labels, specified optimizer ids defined print() output. only_original [`logical(1)] Include optima obtained original problem? parameter_labels [character()] Labels parameters length sum(self$npar).","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Nop Object — Nop","text":"objects class cloneable method.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Nop Object — Nop","text":"","code":"Nop$clone(deep = FALSE)"},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nop Object — Nop","text":"deep Whether make deep clone.","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nop Object — Nop","text":"","code":"### define objective function, optimizer and initial values Nop_ackley <- Nop$new(f = TestFunctions::TF_ackley, npar = 2)$   set_optimizer(optimizeR::Optimizer$new(which = \"stats::nlm\"))$   initialize_random(runs = 20)  ### plot function surface and initial values Nop_ackley |> ggplot2::autoplot()   ### minimize objective function Nop_ackley$optimize(which_direction = \"min\")  ### show optima Nop_ackley$optima(digits = 0) #> # A tibble: 3 × 2 #>   value     n #> * <dbl> <int> #> 1     0     8 #> 2     3     6 #> 3     5     6  ### show best value and parameter across all minimizations Nop_ackley$minimum #> $value #> [1] 4.10729e-07 #>  #> $parameter #> [1] -1.395097e-07 -4.030215e-08 #>"},{"path":"https://loelschlaeger.de/ino/reference/Nop_hmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Example application to HMM likelihood — Nop_hmm","title":"Example application to HMM likelihood — Nop_hmm","text":"object saved reproducibility save computation time building vignettes. See vignette HMM likelihood details object built: https://loelschlaeger.de/ino/articles/example_hmm.html","code":""},{"path":"https://loelschlaeger.de/ino/reference/Nop_hmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example application to HMM likelihood — Nop_hmm","text":"","code":"data(\"Nop_hmm\")"},{"path":"https://loelschlaeger.de/ino/reference/Nop_hmm.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example application to HMM likelihood — Nop_hmm","text":"Nop object.","code":""},{"path":"https://loelschlaeger.de/ino/reference/autoplot.Nop.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting methods — autoplot.Nop","title":"Plotting methods — autoplot.Nop","text":"autoplot.Nop() plots objective function autoplot.Nop_results() plots boxplots optimization results autoplot.Nop_optima() plots bar chart found optima autoplot.Nop_deviation() plots deviations per dimension reference","code":""},{"path":"https://loelschlaeger.de/ino/reference/autoplot.Nop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting methods — autoplot.Nop","text":"","code":"# S3 method for class 'Nop' autoplot(object, xlim = NULL, xlim2 = NULL, ...)  # S3 method for class 'Nop_optima' autoplot(object, ...)  # S3 method for class 'Nop_deviation' autoplot(object, jitter = TRUE, ...)  # S3 method for class 'Nop_results' autoplot(   object,   which_element = \"seconds\",   group_by = NULL,   relative = FALSE,   ... )"},{"path":"https://loelschlaeger.de/ino/reference/autoplot.Nop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting methods — autoplot.Nop","text":"object Depends method: autoplot.Nop(), Nop object autoplot.Nop_results(), value Nop$results autoplot.Nop_optima(), value Nop$optima autoplot.Nop_deviation(), value Nop$deviation xlim, xlim2 [numeric(2)] Ranges first second parameter plot. NULL, derived specified initial values object. ... arguments passed specific methods. jitter [logical(1)] Apply jitter points? which_element [character(1)\\]\\cr column name object` plot. group_by [`character(1)] Selects plot grouped. Either: NULL group, \"optimization\" group optimization label, `\"optimizer\"“ group optimizer label. relative [`logical(1)] Plot values relative overall median?","code":""},{"path":"https://loelschlaeger.de/ino/reference/autoplot.Nop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting methods — autoplot.Nop","text":"ggplot object.","code":""},{"path":"https://loelschlaeger.de/ino/reference/ino-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ino: Initialization of Numerical Optimization — ino-package","title":"ino: Initialization of Numerical Optimization — ino-package","text":"Analysis initialization numerical optimization real-valued functions, particularly likelihood functions statistical models. See https://loelschlaeger.de/ino/ details.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ino/reference/ino-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ino: Initialization of Numerical Optimization — ino-package","text":"Maintainer: Lennart Oelschläger oelschlaeger.lennart@gmail.com (ORCID) Authors: Marius Ötting marius.oetting@uni-bielefeld.de (ORCID) contributors: Dietmar Bauer dietmar.bauer@uni-bielefeld.de [contributor]","code":""},{"path":"https://loelschlaeger.de/ino/news/index.html","id":"ino-110","dir":"Changelog","previous_headings":"","what":"ino 1.1.0","title":"ino 1.1.0","text":"Adapted new optimizeR version. $trace() method transferred trackopt package. changes API.","code":""},{"path":"https://loelschlaeger.de/ino/news/index.html","id":"ino-102","dir":"Changelog","previous_headings":"","what":"ino 1.0.2","title":"ino 1.0.2","text":"CRAN release: 2023-09-29 New $trace() method capture steps optimization stats::nlm().","code":""},{"path":"https://loelschlaeger.de/ino/news/index.html","id":"ino-101","dir":"Changelog","previous_headings":"","what":"ino 1.0.1","title":"ino 1.0.1","text":"CRAN release: 2023-06-05 Minor bug fixes.","code":""},{"path":"https://loelschlaeger.de/ino/news/index.html","id":"ino-100","dir":"Changelog","previous_headings":"","what":"ino 1.0.0","title":"ino 1.0.0","text":"CRAN release: 2023-05-31 package now based R6 class called Nop. See documentation ?Nop details.","code":""},{"path":"https://loelschlaeger.de/ino/news/index.html","id":"ino-010","dir":"Changelog","previous_headings":"","what":"ino 0.1.0","title":"ino 0.1.0","text":"CRAN release: 2022-07-16 Initial version.","code":""}]
